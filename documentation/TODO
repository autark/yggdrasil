* MetaInheritance, build proper support for inheritance.

* Provide a larger test suite.

* Type support

* Transactions.  They must be "requested" by Yggdrasil and handled by
   the storage layer as best possible.

* Historic information.

  How should this be presented?  String of objects, one for every
   timestamp with changes.  However, what if one has two changes
   within 1ms of eachother and enough resolution in the database?

  What do we do with properties and their validity?  If you wish to
   dig up information about Hosts( name, ip, serial ) between
   2008-07-01 and 2008-08-01 and serial was added 2008-07-14, what
   do we return for objects before that timestamp?  Die()ing on a call
   to request the invalid Property would entail having to check
   MetaProperty for the valid Properties for every single object we
   return.  Would that be expensive?  How would it relate to userland?
   Do we guarantee that all Propserties from all objects are valid for
   all objects?

  We might wish to pre-populate the data, it's not current, so there
   is no real reason to ask the database after the initial get.  We
   could set the keys in the objects returned, in essence dumping a
   load of data on userland and saying "here, do what you like with
   this".  We also don't support writing to this data.

* Correction of old data?  What if data has been wrong for a while,
   only in the database though, not in the real world.  It'd show up
   on historic overview as a change today, even if it maybe
   shouldn't.  Tagging updates?

* Caching of properties, it might be a good idea to facilitate a slurp
   of several properties at once to save selects to the database, and
   cache these values for a short time.  Otherwise, just return them
   into a hash or something, to make large-scale property dumps less
   select heavy.

* Handle SET's in _check_valid_types() in Storage.pm
  Eg. SET( VARCHAR(12) )

* If temporal=1, then (currently) the SQL engines use "start" and
  "stop" as fieldnames. That means "start" and "stop" are reserved
  keywords, and a check that the user hasn't requested a field with
  those names. (Or other reserved keywords ... are there any?)

* _register_namespace, what do we do if the namespace is already
  registered?  What is the appropriate behaviour?

* define currently looks like:

  define( Schema',
          fields   => { field1, 
                                { null => BOOL(0), type => type(TEXT), constraint => constraint(undef) }
                        field2, 
                                { null => BOOL(0), type => type(TEXT), constraint => constraint(undef) } },
          temporal => BOOL(0),
          nomap => BOOL(0) );

  This means that the order of the fields is up to the Storage engine.
  This again makes for painful process_database overviews.  Maybe it'd
  be better to do:

  define( Schema',
          fields   => [ field1, 
                                { null => BOOL(0), type => type(TEXT), constraint => constraint(undef) }
                        field2, 
                                { null => BOOL(0), type => type(TEXT), constraint => constraint(undef) } ],
          temporal => BOOL(0),
          nomap => BOOL(0) );

* Store with SERIAL fields need to handle their IDs automatically, we
   can't send an ID value, while not doing so creates undefined values
   in SQL::_store.
