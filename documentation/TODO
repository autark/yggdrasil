* MetaInheritance, build proper support for inheritance.

* Provide a larger test suite.

* Transactions.  They must be "requested" by Yggdrasil and handled by
   the storage layer as best possible.

* Historic information.

  Make current implementation prettier!

  Handle date formats much much better. 

  We might wish to pre-populate the data, it's not current, so there
   is no real reason to ask the database after the initial get.  We
   could set the keys in the objects returned, in essence dumping a
   load of data on userland and saying "here, do what you like with
   this".  We also don't support writing to this data.

* Correction of old data?  What if data has been wrong for a while,
   only in the database though, not in the real world.  It'd show up
   on historic overview as a change today, even if it maybe
   shouldn't.  Tagging updates?

* Caching of properties, it might be a good idea to facilitate a slurp
   of several properties at once to save selects to the database, and
   cache these values for a short time.  Otherwise, just return them
   into a hash or something, to make large-scale property dumps less
   select heavy.

* Handle SET's in _check_valid_types() in Storage.pm
  Eg. SET( VARCHAR(12) )

* If temporal=1, then (currently) the SQL engines use "start" and
  "stop" as fieldnames. That means "start" and "stop" are reserved
  keywords, and a check that the user hasn't requested a field with
  those names. (Or other reserved keywords ... are there any?)

* _register_namespace, what do we do if the namespace is already
  registered?  What is the appropriate behavior?

* Store with SERIAL fields need to handle their IDs automatically, we
   can't send an ID value, while not doing so creates undefined values
   in SQL::_store.

* exists / property_exists need to check what time they're being
   checked for, right now they just check current existence.

* Engine introspection.  
   The storage layer has Storage-related meta information stored (ie,
   types, temporality, mappings and such), is there any information
   the engine should provide?  If so we'll have to declare a shared
   engine level conformance on data structures, for good and bad.  If
   do not go down this road, a field to declare if NULL is acceptable
   as a value for a field should probably be stored in MetaProperty.

* Visual_ids are tunique within each hierarchy.
  If we have Ygg::Person('terjekv'), Ygg::Person::Student( 'terjekv')
  is the same instance.  

* Relations need to support constraints and labels.
  define Ygg::Relation $h, $p, as => 'Hostperson';
  define Ygg::Relation $p, $p,
                       as    => 'Parent',
                       where => 'a.birthdate < b.birthdate';

* Fix relations within the same entity.
  See above, $p to $p, used as:
  $parent->link( $child, as => 'Parent' );
  This will also check that $parent.birthdate < $child.birthdate due
  to the constraint.

* Define a proper syntax for constraints.

* Fix auth / permissions on the web interface.

* Make the web interface support editing.

* We would want "Student" entity that inherits from "Person" and a
  "Student" entity that does not inherit from "Person" to be two
  distinct entities. Today all entities are global, would be nice to
  have "Person::Student" and "Student" as possible entity names.
