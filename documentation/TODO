* MetaInheritance, build proper support for inheritance.

* Provide a larger test suite.

* Transactions.  They must be "requested" by Yggdrasil and handled by
   the storage layer as best possible.

* Historic information.

  Make current implementation prettier!

  Handle date formats much much better. 

  We might wish to pre-populate the data, it's not current, so there
   is no real reason to ask the database after the initial get.  We
   could set the keys in the objects returned, in essence dumping a
   load of data on userland and saying "here, do what you like with
   this".  We also don't support writing to this data.

* Correction of old data?  What if data has been wrong for a while,
   only in the database though, not in the real world.  It'd show up
   on historic overview as a change today, even if it maybe
   shouldn't.  Tagging updates?

   A side note to this is migration of data.  We can't currently
   insert "old" or "raw" data.  The admin interface should probably
   provide something like that.

* Caching of properties, it might be a good idea to facilitate a slurp
   of several properties at once to save selects to the database, and
   cache these values for a short time.  Otherwise, just return them
   into a hash or something, to make large-scale property dumps less
   select heavy.

* Handle SET's in _check_valid_types() in Storage.pm
  Eg. SET( VARCHAR(12) )

* If temporal=1, then (currently) the SQL engines use "start" and
  "stop" as fieldnames. That means "start" and "stop" are reserved
  keywords, and a check that the user hasn't requested a field with
  those names. (Or other reserved keywords ... are there any?)

* _register_namespace, what do we do if the namespace is already
  registered?  What is the appropriate behaviour?

* Store with SERIAL fields need to handle their IDs automatically, we
   can't send an ID value, while not doing so creates undefined values
   in SQL::_store.

* Make sure sure ydump return unix epoch time for stop and start
