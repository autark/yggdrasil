#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Yggdrasil;

my ($zap, $dump, $bootstrap, $dereference, $onlytables) = (0, 1, 0, 1);

my ($user, $password, $host, $port, $db, $engine) =
  ($ENV{YGG_USER}, $ENV{YGG_PASSWORD}, $ENV{YGG_HOST}, $ENV{YGG_PORT}, $ENV{YGG_DB}, $ENV{YGG_ENGINE});


GetOptions(
	   "zap"         => \$zap,
	   "dump!"       => \$dump,
	   "help"        => \&help,
	   "bootstrap"   => \$bootstrap,
	   "dereference" => \$dereference,
	   "tables=s"    => \$onlytables,
	   
	   "user=s"       => \$user,
	   "engine=s"     => \$engine,
	   "password=s"   => \$password,
	   "host=s"       => \$host,
	   "database=s"   => \$db,
	   "engine=s"     => \$engine,
	   "port=s"       => \$port,
	  );

new Yggdrasil(
	      user      => $user,
	      password  => $password,
	      host      => $host,
	      port      => $port,
	      db        => $db,
	      engine    => $engine,
	      namespace => 'Ygg',
	      admin     => 1,
	     );

my $storage = $Yggdrasil::STORAGE;

my ($dbh, $sql);

print "$user\@$host ($db / $engine)\n";

my %mapper;
my %human_to_machine;
my %config;
my (%idents, %entities);

my (@structures, @onlytables, %display_tables);
if ($onlytables) {
    for my $struct (split ",", $onlytables) {
	push @onlytables, $struct unless $display_tables{$struct};
	$display_tables{$struct}++;
    }
    @structures = @onlytables;
} else {
    @structures = $storage->_admin_list_structures();
    
}

my $configstruct = $storage->_dump_structure( 'Storage_config' );
for my $rowref (@$configstruct) {
    $config{$rowref->[0]} = $rowref->[1];
}

my $mapstruct = $storage->_dump_structure( 'Storage_mapname' );
for my $rowref (@$mapstruct) {
    $mapper{$rowref->[1]} = $rowref->[0];
    $human_to_machine{$rowref->[0]} = $rowref->[1];
}

my $realname = $human_to_machine{'Entities'} || 'Entities';
my $tableref = $storage->_dump_structure( $realname );
for my $rowref (@$tableref) {
    my @row = @$rowref;
    $idents{$row[0]} = $row[2];
}

$realname = $human_to_machine{'MetaEntity'} || 'MetaEntity';
$tableref = $storage->_dump_structure( $realname );
for my $rowref (@$tableref) {
    my @row = @$rowref;
    $entities{$row[0]} = $row[1];
}

for my $structure (@structures) {
    my $mapped_struct;

    $structure = $human_to_machine{$structure} if @onlytables && $human_to_machine{$structure};
    
    $mapped_struct = $mapper{$structure} || $structure;	

    if (&display($mapped_struct)) {
	my $displaytext = $mapped_struct;
	$displaytext = "$mapped_struct ($structure)" if $mapped_struct ne $structure;
	print "* $displaytext\n";
    }
    
    my @tabledata;
    if ($dump) {
	next unless &display( $mapped_struct ) || $zap;
	# Give me a row (an array reference) for every row in the structure in question.
	my $tableref = $storage->_dump_structure( $structure );
	for my $rowref (@$tableref) {
	    my @row = @$rowref;

 	    my @data;
	    my $i = 0;
	    my ($lval, $rval) = ();
	    for my $c (@row) {
		if ($dereference && $c && $c =~ /^\d+$/ &&
		    ($mapped_struct =~ /^([a-z]+)_\w+$/i || $mapped_struct =~ /^Meta[RP]/ ||
		     $mapped_struct eq 'Entities' )) {
		    my $key = $1;
		    if ($mapped_struct =~ /^[^_]+_[Rr]_[^_]+/) {
			# id | <id1> | <id2>
			if ($i == 1 || $i == 2) {
			    $c = "$c (" . $idents{$c} . ")";
			}
		    } elsif ($mapped_struct eq 'MetaRelation') {
			if ($i == 1 || $i == 2) {
			    $c = "$c (" . $entities{$c} . ")";
			}
		    } elsif ($mapped_struct eq 'MetaProperty') {
			if ($i == 2) {
			    $c = "$c (" . $entities{$c} . ")";
			}
		    } elsif ($mapped_struct eq 'Entities') {
			if ($i == 1) {
			    $c = "$c (" . $entities{$c} . ")";
			}
		    } else {
			# id | <id>
			if ($i == 0) {
			    $c = "$c (" . $idents{$c} . ")";
			}
		    }
		}
		$i++;
		if (defined $c) {
		    push @data, $c;
		} else {
		    push @data, 'NULL';
		}
	    }
	    push @tabledata, \@data;
	}

	my @widths;
	if (&display($mapped_struct)) {
	    for my $rowref (@tabledata) {
		my $index = 0;
		for my $entry (@$rowref) {
		    my $l = length $entry;
		    $widths[$index] = $l if !$widths[$index] || $l > $widths[$index];
		    $index++;
		}
	    }
	    for my $rowref (@tabledata) {
		my $index = 0;
		my @data;
		for my $entry (@$rowref) {
		    push @data, sprintf "%-@{[$widths[$index]]}s", $entry;
		    $index++;
		}
		printf join(" | ", @data) . "\n";
	    }
	}
	
	print "\n" if &display($mapped_struct);
    } 
    
    if ($zap) {
	# Drop a named structure
	$storage->_admin_delete_structure( $structure );
    } elsif ($bootstrap) {
	if ($structure =~ /Meta/i) {
	    # Truncate a named structure
	    $storage->_admin_truncate_structure( $structure );
	} else {
	    # Drop a named structure
	    $storage->_admin_delete_structure( $structure );
	}
    }
}

sub display {
    my $table = shift;
    
    return 0 if $zap;
    
    return 1 if ! keys %display_tables || $display_tables{$table};
    return 0;
}

sub help {
    print <DATA>;
    exit;
}

__DATA__
Usage: $0 [options]

By default display defined table names.

Options:
--------
--help        Help text
--zap         Zap the entire database
--dump        Dump all tables
--bootstrap   Remove all non-meta tables, truncate meta tables.
--dereference Dereference keys
--tables      Display the comma separated list of tables given only
