#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Yggdrasil::Storage;

my ($zap, $dump, $bootstrap, $dereference, $onlytables) = (0, 1, 0, 1);

GetOptions(
    "zap"         => \$zap,
    "dump!"       => \$dump,
    "help"        => \&help,
    "bootstrap"   => \$bootstrap,
    "dereference" => \$dereference,
    "tables=s"    => \$onlytables,
    );

my $storage = new Yggdrasil::Storage(
				     engine   => $ENV{YGG_ENGINE},
				     db       => $ENV{YGG_DB},
				     host     => $ENV{YGG_HOST},
				     user     => $ENV{YGG_USER},
				     password => $ENV{YGG_PASSWORD},
				     port     => $ENV{YGG_PORT},
				     admin    => 1,
				    );
my ($dbh, $sql);

print "$ENV{YGG_USER}\@$ENV{YGG_HOST}:$ENV{YGG_DB}\n";

my %mapper;
my %config;
my %idents;

my %display_tables;
if ($onlytables) {
    if ($onlytables =~ m|,|) {
	for my $t (split m|,|, $onlytables) {
	    $display_tables{$t}++;
	}
    } else {
	$display_tables{$onlytables}++;
    }
}

# Give me all structures (deref will need 'em even if they're not to be displayed)
for my $structure ($storage->_admin_list_structures()) {
    my $mapped_struct = $mapper{$structure} || $structure;
    
    if (&display($mapped_struct)) {
	my $displaytext = $mapped_struct;
	$displaytext = "$mapped_struct ($structure)" if $mapped_struct ne $structure;
	print "* $displaytext\n";
    }
    my @tabledata;
    if ($dump) {
	# Give me a row (an array reference) for every row in the structure in question.
	my $tableref = $storage->_dump_structure( $structure );
	for my $rowref (@$tableref) {
	    my @row = @$rowref;
	    if ($structure =~ /^[^_]+$/ && $structure !~ /^Meta/) {
		$idents{$mapped_struct}->{$row[0]} = $row[1];
	    } 

	    if (lc $structure eq 'storage_config') {
		$config{$row[0]} = $row[1];
	    } elsif (lc $structure eq 'storage_mapname') {
		$mapper{$row[1]} = $row[0];
	    } 
		    
 	    my @data;
	    my $i = 0;
	    my ($lval, $rval) = ();
	    for my $c (@row) {
		if ($dereference && $c && $c =~ /^\d+$/ && $mapped_struct =~ /^([a-z]+)_\w+$/i) {
		    my $key = $1;
		    if ($mapped_struct =~ /^([^_]+)_[Rr]_([^_]+)/) {
			# id | $1 | $2
			($lval, $rval) = ($1, $2);
			if ($i == 1 && $idents{$lval} && $idents{$lval}->{$c}) {
			    $c = "$c (" . $idents{$lval}->{$c} . ")";
			} elsif ($i == 2 && $idents{$rval} && $idents{$rval}->{$c}) {
			    $c = "$c (" . $idents{$rval}->{$c} . ")";
			}
		    } else {
			if ($i == 0 && $idents{$key} && $idents{$key}->{$c}) {
			    $c = "$c (" . $idents{$key}->{$c} . ")";
			}
		    }
		}
		$i++;
		push @data, $c || 'NULL';
		;
	    }
	    push @tabledata, \@data;
	}

	my @widths;
	if (&display($mapped_struct)) {
	    for my $rowref (@tabledata) {
		my $index = 0;
		for my $entry (@$rowref) {
		    my $l = length $entry;
		    $widths[$index] = $l if !$widths[$index] || $l > $widths[$index];
		    $index++;
		}
	    }
	    for my $rowref (@tabledata) {
		my $index = 0;
		my @data;
		for my $entry (@$rowref) {
		    push @data, sprintf "%-@{[$widths[$index]]}s", $entry;
		    $index++;
		}
		printf join(" | ", @data) . "\n";
	    }
	}
	
	print "\n" if &display($mapped_struct);
    } 
    
    if ($zap) {
	# Drop a named structure
	$storage->_admin_delete_structure( $structure );
    } elsif ($bootstrap) {
	if ($structure =~ /Meta/i) {
	    # Truncate a named structure
	    $storage->_admin_truncate_structure( $structure );
	} else {
	    # Drop a named structure
	    $storage->_admin_delete_structure( $structure );
	}
    }
}

sub display {
    my $table = shift;
    
    return 0 if $zap;
    
    return 1 if ! keys %display_tables || $display_tables{$table};
    return 0;
}

sub help {
    print <DATA>;
    exit;
}

__DATA__
Usage: $0 [options]

By default display defined table names.

Options:
--------
--help        Help text
--zap         Zap the entire database
--dump        Dump all tables
--bootstrap   Remove all non-meta tables, truncate meta tables.
--dereference Dereference keys
--tables      Display the comma separated list of tables given only
