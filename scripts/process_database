#!/usr/bin/perl

use strict;
use warnings;

use DBI;
use Getopt::Long;

my ($zap, $dump, $bootstrap, $dereference, $onlytables) = (0, 1, 0, 1);

GetOptions(
    "zap"         => \$zap,
    "dump!"       => \$dump,
    "help"        => \&help,
    "bootstrap"   => \$bootstrap,
    "dereference" => \$dereference,
    "tables=s"    => \$onlytables,
    );

my ($engine, $db, $host, $user, $password, $port) = ($ENV{YGG_ENGINE},
						     $ENV{YGG_DB},
						     $ENV{YGG_HOST},
						     $ENV{YGG_USER},
						     $ENV{YGG_PASSWORD},
						     $ENV{YGG_PORT},
						    );
my ($dbh, $sql);

my %mapper;
my %config;

my %display_tables;
if ($onlytables) {
    if ($onlytables =~ /,/) {
	for my $t (split /,/, $onlytables) {
	    $display_tables{$t}++;
	} 
    } else {
	$display_tables{$onlytables}++;
    }
}

if (lc $engine eq 'mysql') {
    $sql = "SHOW TABLES";        
} elsif (lc $engine eq 'pg') {    
    $sql = "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'"
}

$dbh = DBI->connect("DBI:$engine:database=$db;host=$host;port=$port", $user, $password );


my %idents;

my $tablesref = $dbh->selectall_arrayref( $sql );

for my $row_arrayref (sort stupidsort @$tablesref) {
    my @row_array = @$row_arrayref;
    my ($mapped_struct, $original_struct) = ($mapper{$row_array[0]} || $row_array[0], $row_array[0]);
    
    if (&display($mapped_struct)) {
	my $displaytext = $mapped_struct;
	$displaytext = "$mapped_struct ($original_struct)" if $mapped_struct ne $original_struct;
	print "* $displaytext\n";
    }
    my @tabledata;
    if ($dump) {
	my $tableref = $dbh->selectall_arrayref( "select * from $original_struct" );	
	for my $rowref (@$tableref) {
	    my @row = @$rowref;
	    if ($original_struct =~ /^[^_]+$/ && $original_struct !~ /^Meta/) {
		$idents{$mapped_struct}->{$row[0]} = $row[1];
	    } 

	    if ($original_struct eq 'Storage_config') {
		$config{$row[0]} = $row[1];
	    } elsif ($original_struct eq 'Storage_mapname') {
		$mapper{$row[1]} = $row[0];
	    } 
		    
 	    my @data;
	    my $i = 0;
	    my ($lval, $rval) = ();
	    for my $c (@row) {
		if ($dereference && $c && $c =~ /^\d+$/ && $mapped_struct =~ /^([a-z]+)_\w+$/i) {
		    my $key = $1;
		    if ($mapped_struct =~ /^([^_]+)_R_([^_]+)/) {
			# id | $1 | $2
			($lval, $rval) = ($1, $2);
			if ($i == 1 && $idents{$lval} && $idents{$lval}->{$c}) {
			    $c = "$c (" . $idents{$lval}->{$c} . ")";
			} elsif ($i == 2 && $idents{$rval} && $idents{$rval}->{$c}) {
			    $c = "$c (" . $idents{$rval}->{$c} . ")";
			}
		    } else {
			if ($i == 0 && $idents{$key} && $idents{$key}->{$c}) {
			    $c = "$c (" . $idents{$key}->{$c} . ")";
			}
		    }
		}
		$i++;
		push @data, $c || 'NULL';
		;
	    }
	    push @tabledata, \@data;
	}

	my @widths;
	if (&display($mapped_struct)) {
	    for my $rowref (@tabledata) {
		my $index = 0;
		for my $entry (@$rowref) {
		    my $l = length $entry;
		    $widths[$index] = $l if !$widths[$index] || $l > $widths[$index];
		    $index++;
		}
	    }
	    for my $rowref (@tabledata) {
		my $index = 0;
		my @data;
		for my $entry (@$rowref) {
		    push @data, sprintf "%-@{[$widths[$index]]}s", $entry;
		    $index++;
		}
		printf join(" | ", @data) . "\n";
	    }
	}
	
	print "\n" if &display($mapped_struct);
    } 
    
    if ($zap) {
	$dbh->do( "DROP TABLE $row_array[0]" );
    } elsif ($bootstrap) {
	if ($row_array[0] =~ /Meta/) {
	    $dbh->do( "TRUNCATE TABLE $row_array[0]");
	} else {
	    $dbh->do( "DROP TABLE $row_array[0]" );
	}
    }
}

sub display {
    my $table = shift;

    return 1 if ! keys %display_tables || $display_tables{$table};
    return 0;
}

sub stupidsort {
    if ($a->[0] =~ /^Meta/) {
	return -1
    } elsif ($a->[0] =~ /^Storage_config/) {
	return 1
    } else {
	$a->[0] cmp $b->[0]
    }
    
}

sub help {
    print <DATA>;
    exit;
}

__DATA__
Usage: $0 [options]

By default display defined table names.

Options:
--------
--help        Help text
--zap         Zap the entire database
--dump        Dump all tables
--bootstrap   Remove all non-meta tables, truncate meta tables.
--dereference Dereference keys
--tables      Display the comma separated list of tables given only
