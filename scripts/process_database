#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Yggdrasil;

my ($zap, $dump, $bootstrap, $dereference, $onlytables) = (0, 1, 0, 1);

GetOptions(
    "zap"         => \$zap,
    "dump!"       => \$dump,
    "help"        => \&help,
    "bootstrap"   => \$bootstrap,
    "dereference" => \$dereference,
    "tables=s"    => \$onlytables,
    );

new Yggdrasil(
	      engine   => $ENV{YGG_ENGINE},
	      db       => $ENV{YGG_DB},
	      host     => $ENV{YGG_HOST},
	      user     => $ENV{YGG_USER},
	      password => $ENV{YGG_PASSWORD},
	      port     => $ENV{YGG_PORT},
	      admin    => 1,
	     );

my $storage = $Yggdrasil::STORAGE;

my ($dbh, $sql);

print "$ENV{YGG_USER}\@$ENV{YGG_HOST}:$ENV{YGG_DB}\n";

my %mapper;
my %human_to_machine;
my %config;
my %idents;

my %display_tables;
if ($onlytables) {
    if ($onlytables =~ m|,|) {
	for my $t (split m|,|, $onlytables) {
	    $display_tables{$t}++;
	}
    } else {
	$display_tables{$onlytables}++;
    }
}

my @structures = $storage->_admin_list_structures();

my $configstruct = $storage->_dump_structure( 'Storage_config' );
for my $rowref (@$configstruct) {
    $config{$rowref->[0]} = $rowref->[1];
}

my $mapstruct = $storage->_dump_structure( 'Storage_mapname' );
for my $rowref (@$mapstruct) {
    $mapper{$rowref->[1]} = $rowref->[0];
    $human_to_machine{$rowref->[0]} = $rowref->[1];
}

my $realname = $human_to_machine{'Entities'} || 'Entities';
my $tableref = $storage->_dump_structure( $realname );
for my $rowref (@$tableref) {
    my @row = @$rowref;
    $idents{$row[0]} = $row[2];
}

for my $structure (@structures) {
    my $mapped_struct = $mapper{$structure} || $structure;
    
    if (&display($mapped_struct)) {
	my $displaytext = $mapped_struct;
	$displaytext = "$mapped_struct ($structure)" if $mapped_struct ne $structure;
	print "* $displaytext\n";
    }
    my @tabledata;
    if ($dump) {
	next unless &display( $mapped_struct ) || $zap;
	# Give me a row (an array reference) for every row in the structure in question.
	my $tableref = $storage->_dump_structure( $structure );
	for my $rowref (@$tableref) {
	    my @row = @$rowref;

 	    my @data;
	    my $i = 0;
	    my ($lval, $rval) = ();
	    for my $c (@row) {
		if ($dereference && $c && $c =~ /^\d+$/ && $mapped_struct =~ /^([a-z]+)_\w+$/i) {
		    my $key = $1;
		    if ($mapped_struct =~ /^[^_]+_[Rr]_[^_]+/) {
			# id | <id1> | <id2>
			if ($i == 1 || $i == 2) {
			    $c = "$c (" . $idents{$c} . ")";
			}
		    } else {
			# id | <id>
			if ($i == 0) {
			    $c = "$c (" . $idents{$c} . ")";
			}
		    }
		}
		$i++;
		if (defined $c) {
		    push @data, $c;
		} else {
		    push @data, 'NULL';
		}
	    }
	    push @tabledata, \@data;
	}

	my @widths;
	if (&display($mapped_struct)) {
	    for my $rowref (@tabledata) {
		my $index = 0;
		for my $entry (@$rowref) {
		    my $l = length $entry;
		    $widths[$index] = $l if !$widths[$index] || $l > $widths[$index];
		    $index++;
		}
	    }
	    for my $rowref (@tabledata) {
		my $index = 0;
		my @data;
		for my $entry (@$rowref) {
		    push @data, sprintf "%-@{[$widths[$index]]}s", $entry;
		    $index++;
		}
		printf join(" | ", @data) . "\n";
	    }
	}
	
	print "\n" if &display($mapped_struct);
    } 
    
    if ($zap) {
	# Drop a named structure
	$storage->_admin_delete_structure( $structure );
    } elsif ($bootstrap) {
	if ($structure =~ /Meta/i) {
	    # Truncate a named structure
	    $storage->_admin_truncate_structure( $structure );
	} else {
	    # Drop a named structure
	    $storage->_admin_delete_structure( $structure );
	}
    }
}

sub display {
    my $table = shift;
    
    return 0 if $zap;
    
    return 1 if ! keys %display_tables || $display_tables{$table};
    return 0;
}

sub help {
    print <DATA>;
    exit;
}

__DATA__
Usage: $0 [options]

By default display defined table names.

Options:
--------
--help        Help text
--zap         Zap the entire database
--dump        Dump all tables
--bootstrap   Remove all non-meta tables, truncate meta tables.
--dereference Dereference keys
--tables      Display the comma separated list of tables given only
