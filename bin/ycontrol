#!/usr/bin/perl

use strict;
use warnings;

BEGIN { our $VERSION = '0.03' };

use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Term::ReadLine;
use Text::ParseWords;

use Crypt::GeneratePassword;

use Yggdrasil;
use Yggdrasil::Common::CommandLine;
use Yggdrasil::Common::Config;

my $cmdline = Yggdrasil::Common::CommandLine->new();
my $label   = $cmdline->get('label') || 'default';

my $c = Yggdrasil::Common::Config->new();
my $config = $c->get($label);
die "No such label as $label\n" unless $config;

my ($dbuser, $password, $host, $port, $db, $engine) =
  ($config->get( 'engineuser' ), $config->get( 'enginepassword' ), $config->get( 'enginehost' ),
   $config->get( 'engineport' ), $config->get( 'enginedb' ), $config->get( 'enginetype' ));

my $y = new Yggdrasil();
my $status = $y->get_status();

$y->connect( 
	    user      => $dbuser,
	    password  => $password,
	    host      => $host,
	    port      => $port,
	    db        => $db,
	    engine    => $engine,
	   );

die $status->message() unless $status->OK();

my $iam;
if ($cmdline->get( 'username' )) {
    $iam = $y->login( user => $cmdline->get( 'username' ), password => $cmdline->get( 'password' ));    
} else {
    $iam = $y->login();
}

die $status->message() unless $status->OK();

my $term = new Term::ReadLine 'ycontrol';
my $attribs = $term->Attribs;
my $OUT = $term->OUT || \*STDOUT;

my %cmd;
%cmd = (
    help => \%cmd,

    user => {
	_help => "User tools",

	info  => {
	    _help => "Show information about a user",
	    _user => \&user_info,
	},

	password => {
	    _help => "Change user password",
	    _user => \&user_password,
	},

	name => {
	    _help => "Change user full name",
	    _user => \&user_fullname,
	},

	create => {
	    _help => "Create new user",
	    _user => \&user_create,
	},

	delete   => {
	    _help => "Delete a user",
	    _user => \&user_delete,
	},

	role => {
	    _help => "User role membership tools", 
	    add   => {
		_help => "Add user to role",
		_user => {
		    _role => \&user_role_add,
		},
	    },
	    remove => {
		_help => "Remove user from role",
		_user => {
		    _role => \&user_role_remove,
		},
		
	    },
	},
    },
    
    role => {
	_help => "Role tools",

	info  => {
	    _help => "Show information about a role",
	    _role => \&role_info,
	},
	
	description => {
	    _help => "Change role description",
	    _role => \&role_description,
	},

	grant => {
	    _help => "Grant role privileges for an entity",

	    read   => {
		_help => "Grant role read privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		}
	    },

	    write  => {
		_help => "Grant role write privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		},
	    },

	    create => {
		_help => "Grant role create privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		},
	    },

	    delete => {
		_help => "Grant role delete privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		},
	    },
	},

	revoke => {
	    _help => "Revoke role privileges for an entity",

	    read   => {
		_help => "Revoke role read privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		}
	    },

	    write  => {
		_help => "Revoke role write privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		},
	    },

	    create => {
		_help => "Revoke role create privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		},
	    },

	    delete => {
		_help => "Revoke role delete privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		},
	    },

	}
    },
    
    entity => {
	_help => "Entity tools",

	info  => {
	    _help   => "Show information about an entity",
	    _entity => \&entity_info,
	},

	create => {
	    _help   => "Create new entity",
	    _entity => \&entity_create,
	},
    },

    property => {
	_help => "Property tools",
	
	create => {
	    _help   => "Create a property",
	    _entity => {
		# This is just a noop, but it works better than letting
		# an existing property be expanded.
		_PROPERTYNAME_ => {
		    _property_type => \&property_create,
		},
	    },
	},
	info => {
            _entity => {
		 _entity_property => \&property_info,
	    },
	},
    },

    instance => {
	_help => "Instance tools",

	info  => {
	    _help   => "Show information about an instance",
	    _entity => {
		_instance => \&instance_info,
	    },
	},
	set => {
	    _help   => "Edit the property of an instance",
	    _entity => {
		_instance => {
		    _instance_property => \&instance_edit,
		},
	    },
	},
	history => {
	    _help   => "Instance history",
	    _entity => {
		_instance => \&instance_history,
	    },
	},
	create => {
	    _entity => {
	        _INSTANCENAME_ => \&instance_create,
	    },
	},
    },
    
    relation => {
	_help => "Relation tools",
	info => {
            _relationlabel => \&relation_info,
	},
        list => \&relation_list,
	create => {
	   _entity => {
	        _entity => \&relation_entities,
                },
	   },
	bind => {
	   _relationlabel => {
	       _instance_left => {
	           _instance_right => \&relation_instances,
               },
	   },
        },    
    },

    transaction => {
	 _help  => 'Transactional information',
         log    => \&transaction_log,
    },
	
    tick => {
	_help => "Tick related commands",
	info  => {
	    _TICK => \&tick_info,
	    },
	intime => {
	    _DATE => \&ticks_in_time,
            },
	current => \&tick_current,
    },

    whoami   => \&whoami,
    storage  => \&storage_info,
    quit     => sub { exit },
    exit     => sub { exit },
);


my %cmd_handler = (
    _user => \&expand_user,
    _role => \&expand_role,
    
    _entity   => \&expand_entity,
    _instance => \&expand_instance,

    _instance_left  => \&expand_instance_relation_left,
    _instance_right => \&expand_instance_relation_right,

    _instance_property => \&expand_instance_property,
    _entity_property   => \&expand_entity_property,
    
    _property_type => \&expand_property_type,

    _relationlabel => \&expand_label,

    _tickstamp => \&expand_tick,
    );

my $prompt = " > ";
my @cmd_path = ();
$attribs->{completion_function} = sub { completion(@_, \%cmd, \@cmd_path) };
$attribs->{completer_quote_characters} = q<"'>;
$attribs->{filename_quote_characters} = q< >;

while ( defined (my $input = $term->readline($prompt)) ) {
    chomp $input;

    if( $input !~ /\S/ ) {
	@cmd_path = ();
	next;
    }
    
    # Add to line what has previously been written
    $input = join(" ", @cmd_path, $input);

    my @this_path;
    my $context = \%cmd;
    for my $key ( shellwords($input) ) {
	if (exists $context->{$key}) {
	    # static command part
	    # "user", "info" etc.
	    $context = $context->{$key};
	    push( @this_path, $key );
	} else {
	    # dynamic command part
	    my( $expander ) = grep { $_ !~ /_help/ } grep { /^_/ } keys %$context;
	    if ( $expander ) {
		$context = $context->{$expander};
		push( @this_path, $key );
	    }
	}
    }

    @cmd_path = @this_path;

    if( @cmd_path && $cmd_path[0] eq "help" ) {
	# display help
	shift @cmd_path while @cmd_path && $cmd_path[0] eq "help";
	help( $context, \@cmd_path );
	@cmd_path = ();
    } elsif (ref $context eq 'CODE') {
	# Reached end of command line
	$context->( @cmd_path );
	@cmd_path = ();
    }
    
} continue {
    # Set prompt
    $prompt = join(" ", @cmd_path) . " > ";
}

sub help {
    my $top  = shift;
    my $path = shift;

    if( ref $top ne "HASH" ) {
	print "No help for '", join(" ", @$path), "'\n";
	return;
    }

    my $prefix = join(" ", @$path);
    for my $key ( sort keys %$top ) {
	if( $key =~ /^_help$/ ) {
	    printf( "%-25s - %s\n", $prefix, $top->{$key} );
	}

	next if $key =~ /^_/;

	my $help = ref $top->{$key} eq "HASH" && exists $top->{$key}->{_help};
	$help = $help ? $top->{$key}->{_help} : '';

	printf( "%-25s - %s\n", join(" ", $prefix, $key), $help );
    }
}

sub whoami {    
    print $y->user->name(), "\n";
}

sub storage_info {
    print $y->info(), "\n";    
}

# Commands
# User interface.
sub user_info {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    printf "%-15s - %s\n", 'Username', $username;
    printf "%-15s - %s\n", 'Full name', $user->fullname() || '';
    printf "%-15s - %s\n", 'Session', $user->session() || '';
    printf "%-15s - %s\n", 'Password', $user->password() || '';
    printf "%-15s - %s\n", 'Roles', join ", ", map { $_->name() } $user->member_of();
    
#    &display_tick( $user->start() );
}

sub user_password {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    my $pass = Crypt::GeneratePassword::word( 6, 10 );
    $user->password( $pass );
    print "New password for '$username' is '$pass'.\n";
}

sub user_fullname {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    my $name = $term->readline(" New full name for '$username' > ");
    print "'$name' is invalid.\n" and return unless defined $name;

    $user->fullname( $name );
    print "New full name for '$username' is '$name'.\n";
}

sub user_role_add {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;

    $role->add( $user );
    print "Added the user '$username' to the role '$rolename'.\n";   
}

sub user_role_remove {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;

    $role->remove( $user );
    print "Removed the user '$username' from the role '$rolename'.\n";   
}

sub user_create {
    my ($user_command, $create_command, $uname) = @_;

    print "'$uname', already taken.\n" and return if $y->get_user( $uname );

    my $uobj = $y->define_user( $uname );
    
    my $name = $term->readline(" Full name > ");
    print "'$name' is invalid.\n" and return unless defined $name;
    $uobj->fullname( $name );
    my $pass = Crypt::GeneratePassword::word( 6, 10 );
    $uobj->password( $pass );
    print "'$uname' created with password '$pass'.\n";
}

sub user_delete {
    my($user_command, $delete_command, $uname) = @_;

    my $uobj = $y->get_user( $uname );
    print "'$uname' does not exist.\n" and return unless $uobj;

    print "Not implemented\n";
}

# Entity interface
sub entity_info {
    my ($entity_command, $info_command, $entity) = @_;
    my $eobj = $y->get_entity( $entity );

    print "'$entity', no such entity.\n" and return unless $eobj;
    
    printf "%-15s - %s\n", 'Name', $entity;

    # Add multiline support.
    my @instances = $eobj->instances();
    printf "%-15s - ", "Instances";
    if (@instances) {
	print join (", ", map { $_->id() } @instances), "\n";
    } else {
	print "NULL\n";
    }

    my @props = $eobj->properties();

    if (@props) {
	print "Properties:\n";
	printf "  %-13s - %-10s - %s\n", 'Name', 'Type', 'Null?';
	for my $prop (@props) {
	    my $type = $prop->type();
	    printf "  %-13s - %-10s - %s\n",  $prop->name(), lc $prop->type(), $prop->null()?'TRUE':'FALSE';
	}
    } else {
	printf "%-15s - NULL\n", "Properties";
    }
    &display_tick( $eobj->start() );
}

sub entity_create {
    my($entity_command, $create_command, $entity) = @_;
    
    my $e = $y->get_entity( $entity );
    
    print "'$entity' already exists ($e).\n" and return if $e;

    my $eobj = $y->define_entity( $entity );
    print "'$entity' created.\n";
}


# Property interface
sub property_create {
    my($property_command, $create_command, $entity, $property, $type) = @_;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my $pobj = $eobj->get_property( $property );
    print "'$property' already exists.\n" and return if $pobj;

    $y->define_property( $property, entity => $eobj, type => $type );
    
    if( $y->get_status()->OK() ) {
	print "'$property' created as $type\n";
    } else {
	print $y->get_status()->message, "\n";
    }
}

sub property_info {
    my($property_command, $info_command, $entity, $property) = @_;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $pobj = $eobj->get_property( $property );
    print "'$property', no such property in '$entity'.\n" and return unless $pobj;
    
    printf "%-15s - %s\n", 'Full name', "$entity:$property";
    printf "%-15s - %s\n%-15s - %s\n", 'Type', lc $pobj->type(), 'Null legal', $pobj->null()?'TRUE':'FALSE';
    
    &display_tick( $pobj->start() );
}

# Instance interface
sub instance_info {
    my ($instance_command, $info_command, $entity, $instance) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $iobj = $eobj->fetch( $instance );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;

    print "$entity / $instance:\n";
    
    my @props = $eobj->properties();
    printf "%-15s - %s\n", 'Property', 'Value' if @props;
    for my $prop (@props) {
	my $value = $iobj->get( $prop ) || '';
	if (length $value > 65) {
	    $value = substr( $value, 0, 60 ) . '[ ... ]';
	}
	
	printf "  %-13s - %s\n", $prop->name(), $value ;
    }

    &display_tick( $iobj->start() );
}

sub instance_edit {
    my ($instance_command, $info_command, $entity, $instance, $property) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $iobj = $eobj->fetch( $instance );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;

    my $pobj = $eobj->property_exists( $property );
    print "'$property', no such property in $entity.\n" and return unless $pobj;

    my $old_value = $iobj->property( $property ) || '';
    my $new_value = $term->readline(" New value for '$property' ($old_value) > ");
    my $retval = $iobj->property( $property, $new_value );

    if (! $status->OK() || ! defined $retval) {
	print "Setting the value of '$property' in '$instance' failed: " . 
	  $status->message() . "\n";
    }
}

sub instance_create {
    my ($instance_command, $create_command, $entity, $instance_name) = @_;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my $iobj = $eobj->fetch( $instance_name );
    print "'$instance_name' already exists in $entity.\n" and return if $iobj;
    
    $iobj = $eobj->create( $instance_name );

    if (! $status->OK()) {
	print $status->message(), "\n";
    } else {
	print "'$instance_name' created in '$entity'.\n";
    }
}

# This doesn't work, we only get one item back from fetch(), we
# probably need to look at _get_in_time in Instance.pm.
sub instance_history {
    my ($instance_command, $info_command, $entity, $instance) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my @iobjs = $eobj->fetch( $instance, 0, undef );
    print "'$instance', no such instance in $entity.\n" and return unless @iobjs;
    my $entries = scalar @iobjs || 0;
    
    print "$entity / $instance (full history, $entries ", $entries > 1?'entries':'entry', "):\n";
    
    my @props = $eobj->properties( 0, undef );
    my (@lines);

    my %maxwidth;
    $maxwidth{start} = $maxwidth{stop} = 6; # default, will be overwritten if length is longer.
    for my $iobj (@iobjs) {
	my %currentline;
	for my $prop ('start', 'stop', @props) {
	    my $propname = ref $prop?$prop->name():$prop;
	    my $value;

	    if ($prop eq 'start') {
		$value = $iobj->start() || 0;
	    } elsif ($prop eq 'stop') {
		$value = $iobj->stop();
	    } else {
		$value = $iobj->get( $propname ) || '';
	    }

	    next unless $value;
            my $length = length $value;
            $maxwidth{$propname} ||= 0;
            $maxwidth{$propname} = $length if $length > $maxwidth{$propname};
	    $currentline{$propname} = $value;
	}
	push @lines, \%currentline;
    }

    my @maxwidth;
    my @header;
    for my $prop ('start', 'stop', @props) {
	my $propname = ref $prop?$prop->name():$prop;
	my $w = $maxwidth{$propname} || 1;
	push @header, sprintf "%-${w}s", $propname;
    }
    print join( ' | ', @header ), "\n";
    
    for my $l (@lines) {
	my @l;
	for my $prop ('start', 'stop', @props) {
	    my $propname = ref $prop?$prop->name():$prop;
	    my $w = $maxwidth{$propname} || 1;
	    push @l, sprintf "%-${w}s", $l->{$propname} || '';
	}
	print join( ' | ', @l ), "\n";
    }
    
}

# Relations
sub relation_entities {
    my ($relation_command, $create_command, $entity1, $entity2) = @_;
    
    return "Identical entities, aborting.\n" if $entity1 eq $entity2;

    my $e1 = $y->get_entity( $entity1 );
    print "Unable to find entity '$e1'\n" and return unless $e1;

    my $e2 = $y->get_entity( $entity2 );
    print "Unable to find entity '$e2'\n" and return unless $e2;
    
    my $r = $y->define_relation( $e1, $e2 );
    if (! $status->OK()) {
	print $status->message(), "\n";
    } else {
	my $lab = $r->label();
	print "Entities '$entity1' and '$entity2' related, with the label '$lab'.\n";
    }
}

sub relation_instances {
    my ($relation_command, $create_command, $label, $i1, $i2) = @_;
    
    my $rel = $y->get_relation( $label );
    print $status->message(), "\n" and return unless $status->OK();

    my ($e1o, $e2o) = $rel->entities();
    
    my $i1o = $e1o->fetch( $i1 );
    print $status->message(), "\n" and return unless $i1o;
    
    my $i2o = $e2o->fetch( $i2 );
    print $status->message(), "\n" and return unless $i2o;

    my $link = $rel->link( $i1o, $i2o );
    print $status->message(), "\n" and return unless $status->OK();
    print "'$i1' is bound to '$i2' via '$label'\n";
}

sub relation_list {
    my ($relation_command, $list_command) = @_;
    print join ", ", $y->relations();
    print "\n";
}

sub relation_info {
    my ($relation_command, $info_command, $label) = @_;

    my $rel = $y->get_relation( $label );
    print $status->message(), "\n" and return unless $status->OK();

    my ($e1o, $e2o) = $rel->entities();
    my @pairs = $rel->participants();
    
    if (@pairs) {
	print "Participants:\n";
	for my $p (@pairs) {
	    my ($li, $ri) = @$p;
	    print join ", ", %$li, "\n";
	    printf "  %20s <-> %20s\n", $li->id(), $ri->id();
	}
    }
    
}

# Tick interface
sub tick_info {
    my ($tick_command, $info_command, $tick) = @_;

    my @ticks;
    my @sequences = split m/,/, $tick;
    
    for my $s (@sequences) {
	if ($s =~ /^(\d+)-(\d+)/) {
	    push @ticks, $_ for ( $1 .. $2 );
	} elsif ($s =~ /^(\d+)$/) {
	    push @ticks, $s;
	} else {
	    print "Unable to parse input, '$s', skipping.\n";
	}
    }

    my @ret = $y->get_ticks( @ticks );
    print "'$tick', no such tick.\n" and return unless $ret[0];
    
    for my $t (@ret) {
	print "Tick ", $t->{id}, ":\n";
	printf "%20s - %s\n", 'Timestamp', $t->{stamp};
	printf "%20s - %s\n", 'Committer', $t->{committer};

	my $eventstring = 'Event';
	for my $e (@{$t->{events}}) {
	    printf "%20s - %s", $eventstring, $e->{string};
	    if ($e->{stop}) {
		print " (expired tick " . $e->{stop} . ")\n";
	    } else {
		print " (still valid)\n";
	    }
	    $eventstring = '';
	}	
    }
    print "\n";
}

sub tick_current {
    my ($tick_command, $current_command) = @_;

    my @ticks = $y->get_ticks_by_time( time );
    print $ticks[0]->{id}, "\n";
}

sub ticks_in_time {
    my ($tick_command, $info_command, $time) = @_;
    my ($to, $from) = split / to /, $time;

    my @ticks = $y->get_ticks_by_time( $to, $from );
    
    print "No ticks for the given time.\n" and return unless @ticks;

    printf "%10s - %20s - %s\n", 'Tick', 'Timestamp', 'Committer';
    for my $tick (@ticks) {
	printf "%10d - %20s - %s\n", $tick->{id}, $tick->{stamp}, $tick->{committer};
    }
    
}

# Role interface
sub role_info {
    my ($role_command, $info_command, $rolename) = @_;
    my $robj = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $robj;
    
    print "${rolename}:\n";
    printf "%20s - %s\n", 'Description', $robj->description() || '';
    printf "%20s - %s\n", 'Members', join ", ", map { $_->id() } $robj->members();
}

sub role_description {
    my($role_command, $desc_command, $role) = @_;
    
    my $robj = $y->get_role( $role );
    print "'$role', no such role.\n" and return unless $robj;

    my $desc = $term->readline(" New description for role '$role' > ");
    print "'$desc' is invalid.\n" and return unless defined $desc;

    $robj->description( $desc );
    print "New description for '$role' is '$desc'.\n";
}

sub role_grant {
    my($role_command, $grant_command, $privilege, $role, $entity) = @_;

    grant_revoke( $grant_command, $privilege, $role, $entity );
}

sub role_revoke {
    my($role_command, $revoke_command, $privilege, $role, $entity) = @_;
    
    grant_revoke( $revoke_command, $privilege, $role, $entity );
}

sub grant_revoke {
    my( $type, $privilege, $role, $entity ) = @_;

    my $robj = $y->get_role( $role );
    print "'$role', no such role.\n" and return unless $robj;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my %tag = (
	read   => 'r',
	write  => 'w',
	create => 'c',
	delete => 'd',
    );
    print "'$privilege', no such privilege.\n" and return unless $tag{$privilege};

    if( $type eq "grant" ) {
	$robj->grant( $eobj, $tag{$privilege} );
	print "Granted role '$role' $privilege privileges to $entity\n"; 
    } elsif( $type eq "revoke" ) {
	$robj->revoke( $eobj, $tag{$privilege} );
	print "Revoked role '$role' $privilege privileges to $entity\n"; 
    } else {
	print "'$type', no such type.\n";
	return;
    }

}

sub transaction_log {
    my @entries = $y->transaction_stack_get();
    print "Transaction stack empty.\n" and return unless @entries;
    
    print "Transaction stack:\n";
    for my $entry (@entries) {
	printf " %05d | %-7s | %s\n", $entry->id(), $entry->path(), join( ', ', $entry->get_commit_log());
	for my $engine ($entry->get_engine_log()) {
	    print "       | $engine\n";
	}
    }
    $y->transaction_stack_clear();
}

# Helper stuff.
sub display_tick {
    my $tickid = shift;
    my @tick = $y->get_ticks( $tickid );
    printf "%-15s - %s (%d)\n", 'Created', $tick[0]->{stamp}, $tickid;
    printf "%-15s - %s\n", 'Committer', $tick[0]->{committer};
}

# Yggdrasil expand interface.
# WARNING, Yggdrasil is returning labels, not objects here!
sub expand_label {
    return $y->relations();
}

sub expand_user {
    return $y->usernames();
}

sub expand_role {
    return $y->rolenames();
}

sub expand_entity {
    return map { $_->name() } $y->entities();
}

sub expand_instance {
    my( $instance, $entity ) = @_;

    my $eobj = $y->get_entity( $entity );
    return unless $eobj;

    return map { $_->id() } $eobj->instances();    
}

sub expand_instance_relation {
    my( $side, $instance, $relation ) = @_;

    my $rel = $y->get_relation( $relation );
    my ($left, $right) = $rel->entities();

    if ($side eq 'l') {
	return map { $_->id() } $left->instances();	
    } else {
	return map { $_->id() } $right->instances();
    }
}

sub expand_instance_relation_left {
    my( $left, $relation ) = @_;
    return expand_instance_relation( 'l', $left, $relation );
}

sub expand_instance_relation_right {
    my( $right, $left, $relation ) = @_;
    return expand_instance_relation( 'r', $right, $relation );
}

sub expand_entity_property {
    my( $prop, $entity ) = @_;

    my $eobj = $y->get_entity( $entity );
    return unless $eobj;

    return map { $_->name() } $eobj->properties();    
}

sub expand_instance_property {
    my( $prop, $instance, $entity ) = @_;

    return expand_entity_property( $prop, $entity );
}


sub expand_property_type {
    return $y->property_types();
}

sub completion {
    my $word  = shift;
    my $line  = shift;
    my $start = shift;
    my $top   = shift;
    my $path  = shift;

    $attribs->{filename_completion_desired} = 1;

    # Add to line what has previously been written
    $line = join(" ", @$path, $line);

    # All "words" before the one we are writing 'now'
    my @commands = lineparser( $line );

    # add the word we are about to write now (if it's empty)
    push( @commands, $word ) if $word !~ /\S/;

    for( my $i=0; $i<@commands; $i++ ) {
	my $c = $commands[$i];

	# reached end of command line
	return if ref $top eq 'CODE';

	if (exists $top->{$c}) {
	    # static command part
	    # "user", "info" etc.
	    $top = $top->{$c};
	} elsif ( $i < $#commands ) {
	    # dynamic command part
	    # only go to next level if a whole word has been written
	    # and we are currently writing the next one
	    my( $expander ) = grep { $_ !~ /^_help$/ } grep { /^_/ } keys %$top;
	    $top = $top->{$expander} if $expander;
	}
    } 

    return 
	map {
	    if ($cmd_handler{$_}) {
		# Grab command handlers
		$cmd_handler{$_}->( reverse @commands );
	    } elsif ($_ =~ /^_/) {
		# Strip _-commands, like _desc as well.
	    } else {
		# Otherwise, return the key raw.
		$_;
	    }
	} keys %$top if ref $top eq 'HASH';
    
    return;
}

# wrapper around shellwords that can handle unclosed quotes
sub lineparser {
    my $line = shift;
    
    return unless length $line;

    my @r = shellwords( $line );
    unless( @r ) {
	my $closed = $line . '"';
	@r = shellwords( $closed );
    }

    unless( @r ) {
	my $closed = $line . "'";
	@r = shellwords( $closed );
    }

    return grep { defined && length } @r;
}

__DATA__
ycontrol is a command line interface to directly manipulate Yggdrasil
structures.
  
For help with ycontrol operation, type 'help' at the command prompt, most
operators are documented directly.  If you have any further questions, 
please see the Yggdrasil documentation.

