#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Term::ReadLine;
use Text::ParseWords;

use Crypt::GeneratePassword;

use Yggdrasil;

my ($dbuser, $password, $host, $port, $db, $engine) =
  ($ENV{YGG_USER}, $ENV{YGG_PASSWORD}, $ENV{YGG_HOST}, $ENV{YGG_PORT}, $ENV{YGG_DB}, $ENV{YGG_ENGINE});

my $y = new Yggdrasil();
my $status = $y->get_status();

$y->connect( 
	    user      => $dbuser,
	    password  => $password,
	    host      => $host,
	    port      => $port,
	    db        => $db,
	    engine    => $engine,
	   );

die $status->message() unless $status->OK();

my $iam = $y->login();
my @roles = $iam->get_cached_member_of();

die $status->message() unless $status->OK();

my $term = new Term::ReadLine 'ycontrol';
my $attribs = $term->Attribs;
my $OUT = $term->OUT || \*STDOUT;
$attribs->{attempted_completion_function} = \&attempt_completion;

my %cmd = (
	   help => {},
	   user => {		    
		    info  => {
			      _user => \&user_info,
			     },
		    password => {
				 _user => \&user_password,
				},
		    name => {
			     _user => \&user_fullname,
			    },
		    create   => \&user_create,
		    delete   => {
				 _user => \&user_delete,
				},
		    role => {
			     add    => {
					_user => {
						  _role => \&user_role_add,
						 },
				       },
			     remove => {
					_user => {
						  _role => \&user_role_remove,
						 },
					
				       },
			    },
		   },

	   role => {
		    info => {
			     _role => \&role_info,
			    }
		   },

	   entity => {
		      info => {
			       _entity => \&entity_info,
			      },
		     },

	   instance => {
			info => {
				 _entity => {
					     _instance => \&instance_info,
					    },
				},
		       },

	   relation => {
		       },
	   quit     => sub { exit },
	   exit     => sub { exit },
	  );

my %cmd_handler = (
		   _user => \&expand_user,
		   _role => \&expand_role,

		   _entity   => \&expand_entity,
		   _property => \&expand_property,
		   _instance => \&expand_instance,
		  );

my ($input, $context) = ('', \%cmd);
while ( defined ($input = $term->readline(' > ')) ) {
    chomp $input;
    next unless $input =~ /\S/;
    my $original = $input;

    my @path;
    for my $key (shellwords( $input )) {
	if (exists $context->{$key}) {
	    $context = $context->{$key};
	    push( @path, $key );
	} else {
	    my @magicshit = grep { /^_/ } keys %$context;
	    if (@magicshit) {
		$context = $context->{$magicshit[0]};
		push( @path, $key );
	    }
	}
    }

    if (ref $context eq 'CODE') {
	$context->( @path );
	$context = \%cmd;	
    }
    
    $term->set_prompt( join(" ", @path) );
    $term->addhistory($original);
}

# Commands
# User interface.
sub user_info {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    printf "%20s - %s\n", 'Username', $username;
    printf "%20s - %s\n", 'Full name', $user->fullname() || '';
    printf "%20s - %s\n", 'Session', $user->session() || '';
    printf "%20s - %s\n", 'Password', $user->password() || '';
    printf "%20s - %s\n", 'Roles', join ", ", map { $_->name() } $user->member_of();
}

sub user_password {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    my $pass = Crypt::GeneratePassword::word( 6, 10 );
    $user->password( $pass );
    print "New password for '$username' is '$pass'.\n";
}

sub user_fullname {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    $context = {};
    my $name = $term->readline(" New full name for '$username' > ");
    print "'$name' is invalid.\n" and return unless defined $name;

    $user->fullname( $name );
    print "New full name for '$username' is '$name'.\n";
}

sub user_role_add {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;

    $role->add( $user );
    print "Added the user '$username' to the role '$rolename'.\n";   
}

sub user_role_remove {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;

    $role->remove( $user );
    print "Removed the user '$username' from the role '$rolename'.\n";   
}

sub user_create {
    my ($user_command, $create_command) = @_;

    my $uname = $term->readline(" Username > ");
    print "'$uname', already taken.\n" and return if $y->get_user( $uname );

    my $uobj = $y->define_user( $uname );
    
    my $name = $term->readline(" Full name > ");
    print "'$name' is invalid.\n" and return unless defined $name;
    $uobj->fullname( $name );
    my $pass = Crypt::GeneratePassword::word( 6, 10 );
    $uobj->password( $pass );
    print "'$uname' created with password '$pass'.\n";
}

# Entity interface
sub entity_info {
    my ($entity_command, $info_command, $entity) = @_;
    my $eobj = $y->get_entity( $entity );

    print "'$entity', no such entity.\n" and return unless $eobj;
    
    printf "%15s - %s\n", 'Name', $entity;

    # Add multiline support.
    print "Instances:\n";
    printf "  %s\n", join ", ", map { $_->id() } $eobj->instances();

    print "Properties:\n";
    printf "  %-13s - %5s - %s\n", 'Name', 'Null?', 'Type';
    for my $prop ($eobj->properties()) {
#	printf "  %13s - %5s - %s\n",  $prop->name(), $prop->null?'TRUE':'FALSE', $prop->type();
	printf "  %-13s - %5s - %s\n",  $prop->name(), '?', '?';
    }

}

# Instance interface
sub instance_info {
    my ($instance_command, $info_command, $entity, $instance) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $iobj = $eobj->fetch( $instance );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;

    print "$entity / $instance:\n";
    
    my @props = $eobj->properties();
    printf "%-15s - %s\n", 'Property', 'Value' if @props;
    for my $prop (@props) {
	printf "%-15s - %s\n", $prop->name(), $iobj->get( $prop ) || '';
    }    
}

# Role interface
sub role_info {
    my ($role_command, $info_command, $rolename) = @_;
    my $robj = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $robj;
    
    print "${rolename}:\n";
    printf "%20s - %s\n", 'Description', $robj->description() || '';
    printf "%20s - %s\n", 'Members', join ", ", map { $_->id() } $robj->members();

}



# Yggdrasil expand interface.
sub expand_user {
    my $eobj = $y->get_entity( 'MetaAuthUser' );
    return map { $_->id() } $eobj->instances();
}

sub expand_role {
    my $eobj = $y->get_entity( 'MetaAuthRole' );
    return map { $_->id() } $eobj->instances();
}


sub expand_entity {
    return map { $_->name() } $y->entities();   
}

sub expand_property {
    my $entity = shift;
    my $eobj = $y->get_entity( $entity );
    
    return unless $eobj;
    return map { $_->name() } $eobj->properties();    
}

sub expand_instance {
    my $entity = shift;
    my $eobj = $y->get_entity( $entity );
    
    return unless $eobj;
    return map { $_->id() } $eobj->instances();    
}


# Don't go here.
my ($i, @m, @commands);
sub attempt_completion {
    my $word = shift;
    my $line = shift;
    my $start = shift;
    my $stop  = shift;

    # All "words" before the one we are writing 'now'
    @commands = shellwords( substr( $line, 0, $start ) );
    
    return $term->completion_matches( $word, \&expand_start );
}

sub expand_start {
    my $word = shift;
    my $state = shift;
    
    #    print " * @commands\n";
    #    print "\n ** $word: $state\n";
    unless( $state ) {
	my $top = $context;
	for my $c (@commands) {
	    if (ref $top eq 'CODE') {
		return;
	    } elsif (exists $top->{$c}) {
		$top = $top->{$c};
	    } else {
		my @magicshit = grep { /^_/ } keys %$top;
		if (@magicshit) {
		    $top = $top->{$magicshit[0]};
		}
	    }
	}
	@m = map {
	    if ($cmd_handler{$_}) {		
		# Grab command handlers
		$cmd_handler{$_}->( reverse @commands );
	    } elsif ($_ =~ /^_/) {
		# Strip _-commands, like _desc as well.
	    } else {
		# Otherwise, return the key raw.
		$_;
	    }
	} keys %$top if ref $top eq 'HASH';
    } else { $i++; }

    return expand($word, \@m);
}

sub expand {
    my $word = shift;
    my @m    = @{$_[0]};
    
    for($i||=0 ; $i<@m; $i++ ) {
	return $m[$i] unless length($word);
	return $m[$i] if $m[$i] =~ /^\Q$word/;
    }

    $i = 0;
    return;
}
