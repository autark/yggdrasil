#!/usr/bin/perl

use strict;
use warnings;

BEGIN { our $VERSION = '0.03' };

use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Term::ReadLine;
use Text::ParseWords;

use Crypt::GeneratePassword;

use Yggdrasil;
use Yggdrasil::Common::CommandLine;
use Yggdrasil::Common::Config;

my $cmdline = Yggdrasil::Common::CommandLine->new();
my $label   = $cmdline->get('label') || 'default';

my $c = Yggdrasil::Common::Config->new();
my $config = $c->get($label);

unless ($config) {
    $config = $c->get('ENV');
    die "No such label as $label and falling back to ENV failed\n"
	unless $config->get( 'engineuser' );
}

my ($dbuser, $password, $host, $port, $db, $engine) =
  ($config->get( 'engineuser' ), $config->get( 'enginepassword' ), $config->get( 'enginehost' ),
   $config->get( 'engineport' ), $config->get( 'enginedb' ), $config->get( 'enginetype' ));

my $y = new Yggdrasil();
my $status = $y->get_status();

$y->connect( 
	    user      => $dbuser,
	    password  => $password,
	    host      => $host,
	    port      => $port,
	    db        => $db,
	    engine    => $engine,
	    
	    daemonhost => $config->get( 'daemonhost' ),
	    daemonport => $config->get( 'daemonport' ),
	   );

die $status->message(), "\n" unless $status->OK();

my $uname = $cmdline->get( 'username' ) || $config->get( 'authuser' ) || (getpwuid($>))[0];
my $upass = $cmdline->get( 'password' ) || $config->get( 'authpass' ) || $cmdline->read_password();
my $iam = $y->login( username => $uname, password => $upass );    

die $status->message(), "\n" unless $status->OK();

my $term = new Term::ReadLine 'ycontrol';
my $attribs = $term->Attribs;
my $OUT = $term->OUT || \*STDOUT;

my ($start, $stop) = (0, 0);

my %cmd;
%cmd = (
    help => \%cmd,

    user => {
	_help => "User tools",

	info  => {
	    _help => "Show information about a user",
	    _user => \&user_info,
	},

	password => {
	    _help => "Change user password",
	    _user => \&user_password,
	},

	name => {
	    _help => "Change user full name",
	    _user => \&user_fullname,
	},

	create => {
	    _help => "Create new user",
	    _user => \&user_create,
	},

	expire   => {
	    _help => "Expire a user",
	    _user => \&user_expire,
	},

	role => {
	    _help => "User role membership tools", 
	    add   => {
		_help => "Add user to role",
		_user => {
		    _role => \&user_role_add,
		},
	    },
	    remove => {
		_help => "Remove user from role",
		_user => {
		    _role => \&user_role_remove,
		},
		
	    },
	},
    },
    
    role => {
	_help => "Role tools",

	info  => {
	    _help => "Show information about a role",
	    _role => \&role_info,
	},
	
	description => {
	    _help => "Change role description",
	    _role => \&role_description,
	},

	create => {
	    _help => "Create new role",
	    _role => \&role_create,
	},

	grant => {
	    _help => "Grant role privileges",

	    read   => {
		_help => "Grant role read privileges",
		_role => {
			  entity    => { _entity => \&role_grant },
			  instance  => { _entity => { _instance => \&role_grant } },
			  relation  => { _relationlabel => \&role_grant },
			  property  => { _entity => { _entity_property => \&role_grant } },
			  iproperty => { _entity => { _instance => { _instance_property => \&role_grant } } },
		}
	    },

	    write  => {
		_help => "Grant role write privileges",
		_role => {
			  entity    => { _entity => \&role_grant },
			  instance  => { _entity => { _instance => \&role_grant } },
			  relation  => { _relationlabel => \&role_grant },
			  property  => { _entity => { _entity_property => \&role_grant } },
			  iproperty => { _entity => { _instance => { _instance_property => \&role_grant } } },
		},
	    },

	    modify => {
		_help => "Grant role modify privileges",
		_role => {
			  entity    => { _entity => \&role_grant },
			  instance  => { _entity => { _instance => \&role_grant } },
			  relation  => { _relationlabel => \&role_grant },
			  property  => { _entity => { _entity_property => \&role_grant } },
			  iproperty => { _entity => { _instance => { _instance_property => \&role_grant } } },
		},
	    },
	},

	revoke => {
	    _help => "Revoke role privileges",

	    read   => {
		_help => "Revoke role read privileges",
		_role => {
			  entity    => { _entity => \&role_revoke },
			  instance  => { _entity => { _instance => \&role_revoke } },
			  relation  => { _relationlabel => \&role_revoke },
			  property  => { _entity => { _entity_property => \&role_revoke } },
			  iproperty => { _entity => { _instance => { _instance_property => \&role_revoke } } },
		},
	    },

	    write  => {
		_help => "Revoke role write privileges",
		_role => {
			  entity    => { _entity => \&role_revoke },
			  instance  => { _entity => { _instance => \&role_revoke } },
			  relation  => { _relationlabel => \&role_revoke },
			  property  => { _entity => { _entity_property => \&role_revoke } },
			  iproperty => { _entity => { _instance => { _instance_property => \&role_revoke } } },
		},
	    },

	    modify => {
		_help => "Revoke role modify privileges",
		_role => {
			  entity    => { _entity => \&role_revoke },
			  instance  => { _entity => { _instance => \&role_revoke } },
			  relation  => { _relationlabel => \&role_revoke },
			  property  => { _entity => { _entity_property => \&role_revoke } },
			  iproperty => { _entity => { _instance => { _instance_property => \&role_revoke } } },
		},
	    },
	}
    },
    
    entity => {
	_help => "Entity tools",

	info  => {
	    _help   => "Show information about an entity",
	    _entity => \&entity_info,
	},

	create => {
	    _help   => "Create new entity",
	    _ENTITYNAME_ => \&entity_create,
	},
	expire => {
	    _help   => "Expire an entity, its properties and its instances.",
	    _entity => \&entity_expire,
	},
	find_instance => {
	    _help   => "Search for instances based on .",
	    _entity => { _entity_property => { _SEARCH_STRING_ => \&entity_search } },
	},
    },

    property => {
	_help => "Property tools",
	
	create => {
	    _help   => "Create a property",
	    _entity => {
		# This is just a noop, but it works better than letting
		# an existing property be expanded.
		_PROPERTYNAME_ => {
		    _property_type => {
			_BOOLEAN_ => \&property_create,
		    },
		},
	    },
	},
	info => {
            _entity => {
		 _entity_property => \&property_info,
	    },
	},
	expire => {
	    _help => 'Expire a property, this will also expire all values of any instance using this property',
	    _entity => {
		_entity_property => \&property_expire,
		},		   
	    },
	types => \&property_types,
    },

    instance => {
	_help => "Instance tools",

	info  => {
	    _help   => "Show information about an instance",
	    _entity => {
		_instance => \&instance_info,
	    },
	},
	expire => {
	    _help   => "Expire an instance",
	    _entity => {
		_instance => \&instance_expire,
	    },
	},
	set => {
	    _help   => "Edit the property of an instance",
	    _entity => {
		_instance => {
		    _instance_property => \&instance_edit,
		},
	    },
	},
	history => {
	    _help    => "Instance history",
	    full     => { _entity => { _instance => \&instance_history } },
	    property => { _entity => { _instance => { _instance_property => \&instance_property_history } } },
	},
	create => {
	    _entity => {
	        _INSTANCENAME_ => \&instance_create,
	    },
	},
    },
    
    relation => {
	_help => "Relation tools",
	info => {
            _relationlabel => \&relation_info,
	},
        list => \&relation_list,
	create => {
	   _entity => {
	        _entity => \&relation_entities,
                },
	   },
	bind => {
	   _relationlabel => {
	       _instance_left => {
	           _instance_right => \&relation_instances,
               },
	   },
        },
	expire => {
		   _relationlabel => \&relation_expire,
	},
    },

    transaction => {
	 _help  => 'Transactional information',
         log    => \&transaction_log,
    },
	
    tick => {
	_help => "Tick related commands",
	info  => {
	    _TICK_ => \&tick_info,
	    },
	intime => {
	    _DATE_ => \&ticks_in_time,
            },
	current => \&tick_current,
    },

    set => {
        debug => {
            _help => 'Turn on / off debugging options',
	    _DEBUGOPTIONS_ => {
	       _DEBUGTOGGLE_ => \&set_debug,
            },
        },
	temporal => {
	    start => { _TICK_ => \&set_start },
	    stop  => { _TICK_ => \&set_stop  },
	    current => \&unset_start_and_stop,
        },
    },

    search     => { _help => 'Search for entities, instances, properties and relations containing the given string',
		    _SEARCH_STRING_ => \&ygg_search,
		  },
    	
    whoami     => \&whoami,
    uptime     => \&uptime,
    protocols  => \&protocols,
    serverdata => \&server_data,
    storage    => \&storage_info,
    cache      => \&cache_info,
    quit       => sub { exit },
    exit       => sub { exit },
);

my %debug_switches;

for my $switch ($y->debug_switches()) {
    $debug_switches{$switch} = 0;
} 

my %cmd_handler = (
    _user => \&expand_user,
    _role => \&expand_role,
    
    _entity   => \&expand_entity,
    _instance => \&expand_instance,

    _instance_left  => \&expand_instance_relation_left,
    _instance_right => \&expand_instance_relation_right,

    _instance_property => \&expand_instance_property,
    _entity_property   => \&expand_entity_property,
    
    _property_type => \&expand_property_type,

    _relationlabel => \&expand_label,

    _tickstamp => \&expand_tick,

    _ENTITYNAME_   => sub { return ("<entityname>") },
    _PROPERTYNAME_ => sub { return ("<propertyname>") },
    _INSTANCENAME_ => sub { return ("<instancename>") },
    _TICK_         => sub { return ("<ticknumber>") },
    _DATE_         => sub { return ("<isodate>") },
    _BOOLEAN_      => sub { return qw/true false/ },
    _DEBUGTOGGLE_  => sub { return $debug_switches{$_[1]}?'off':'on'; },
    _DEBUGOPTIONS_ => sub { return keys %debug_switches },
    );

my $prompt = " > ";
my @cmd_path = ();
$attribs->{completion_function} = sub { completion(@_, \%cmd, \@cmd_path) };
$attribs->{completer_quote_characters} = q<"'>;
$attribs->{filename_quote_characters} = q( <->);

while ( defined (my $input = $term->readline($prompt)) ) {
    chomp $input;

    if( $input !~ /\S/ ) {
	@cmd_path = ();
	next;
    }
    
    # Add to line what has previously been written
    $input = join(" ", @cmd_path, $input);

    my @this_path;
    my $context = \%cmd;
    for my $key ( shellwords($input) ) {
	unless (ref $context eq 'HASH') {
	    print "Spurious input '$key' ignored\n";
	    next;
	} 
	if (exists $context->{$key}) {
	    # static command part
	    # "user", "info" etc.
	    $context = $context->{$key};
	    push( @this_path, $key );
	} else {
	    # dynamic command part
	    my( $expander ) = grep { $_ !~ /_help/ } grep { /^_/ } keys %$context;
	    if ( $expander ) {
		$context = $context->{$expander};
		push( @this_path, $key );
	    }
	}
    }

    @cmd_path = @this_path;

    if( @cmd_path && $cmd_path[0] eq "help" ) {
	# display help
	shift @cmd_path while @cmd_path && $cmd_path[0] eq "help";
	help( $context, \@cmd_path );
	@cmd_path = ();
    } elsif (ref $context eq 'CODE') {
	# Reached end of command line
	$context->( @cmd_path );
	@cmd_path = ();
    }
    
} continue {
    # Set prompt
    $prompt = join(" ", @cmd_path) . " > ";
}

sub help {
    my $top  = shift;
    my $path = shift;

    if( ref $top ne "HASH" ) {
	print "No help for '", join(" ", @$path), "'\n";
	return;
    }

    my $prefix = join(" ", @$path);
    for my $key ( sort keys %$top ) {
	if( $key =~ /^_help$/ ) {
	    printf( "%-25s - %s\n", $prefix, $top->{$key} );
	}

	next if $key =~ /^_/;

	my $help = ref $top->{$key} eq "HASH" && exists $top->{$key}->{_help};
	$help = $help ? $top->{$key}->{_help} : '';

	printf( "%-25s - %s\n", join(" ", $prefix, $key), $help );
    }
}

sub set_start {
    my ($set, $temporality, $startcommand, $starttime) = @_;
    $start = $starttime;
}

sub set_stop {
    my ($set, $temporality, $stopcommand, $stoptime) = @_;
    $stop = $stoptime;
}

sub unset_start_and_stop {
    $stop = $start = undef;
}

sub set_debug {
    my ($set, $debug, $command, $switch) = @_;
    
    unless (exists $debug_switches{$command}) {
	print "Unknown debug command, '$command'\n";
	return;
    }
    
    if ($switch =~ m/(true|on)/i) {
	$y->storage()->debug( $command => 1 );
	print "Toggled debug command '$command' on\n";
	$debug_switches{$command} = 1;
    } else {
	$y->storage()->debug( $command => 0 );	
	print "Toggled debug command '$command' off\n";
	$debug_switches{$command} = 0;
    }
}

sub whoami {    
    print $y->whoami(), "\n";
}

sub uptime {    
    print $y->uptime(), "\n";
}

sub server_data {    
    for my $data ($y->server_data()) {
	print "$data\n";
    }
}

sub protocols {    
    print join( ',', $y->protocols() ), "\n";
}

sub storage_info {
    print $y->info(), "\n";    
}

# Commands
# User interface.
sub user_info {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    printf "%-15s - %s\n", 'Username', $username;
    printf "%-15s - %s\n", 'Full name', $user->fullname() || '';
    printf "%-15s - %s\n", 'Session', $user->session() || '';
    printf "%-15s - %s\n", 'Password', $user->password() || '';
    printf "%-15s - %s\n", 'Roles', join ", ", map { $_->id() } $user->member_of();
    
    display_tick( $user );
}

sub user_password {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    my $pass;
    my $display_pass;
    if ($username eq $y->user()) {
	$pass = _read_password();
	unless ($pass) {
	    print "Passwords not entered correctly, aborting.\n";
	    return;
	}
    } else {
	$pass = Crypt::GeneratePassword::word( 6, 10 );
	$display_pass = 1;
    }
    $user->password( $pass );
    if( $status->OK() ) {
	printf "New password for '$username' is %s.\n", $display_pass?"'$pass'":'active';
    } else {
	print $status->message(), "\n";
    }
}

sub user_fullname {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    my $name = $term->readline(" New full name for '$username' > ");
    print "'$name' is invalid.\n" and return unless defined $name;
    $user->fullname( $name );
    if( $status->OK() ) {
	print "New full name for '$username' is '$name'.\n";
    } else {
	print $status->message(), "\n";
    }
}

sub user_role_add {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;
    $role->add( $user );
    print "Added the user '$username' to the role '$rolename'.\n";   
}

sub user_role_remove {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;

    $role->remove( $user );
    print "Removed the user '$username' from the role '$rolename'.\n";   
}

sub user_create {
    my ($user_command, $create_command, $uname) = @_;

    print "'$uname', already taken.\n" and return if $y->get_user( $uname );

    my $uobj = $y->define_user( $uname );
    print $status->message(), "\n" and return unless $status->OK();

    my $name = $term->readline(" Full name > ");
    print "'$name' is invalid.\n" and return unless defined $name;
    $uobj->fullname( $name );
    my $pass = Crypt::GeneratePassword::word( 6, 10 );
    $uobj->password( $pass );
    print "'$uname' created with password '$pass'.\n";
}

sub user_expire {
    my($user_command, $expire_command, $uname) = @_;

    $y->expire_user( $uname );
    print $status->message(), "\n";
}

# Entity interface
sub entity_info {
    my ($entity_command, $info_command, $entity) = @_;
    my ($key, $tstart, $tstop) = extract_temporality( $entity );
    my $eobj;
    
    $eobj = $y->get_entity( $key, populate_times( $tstart, $tstop ) );
    my $status = $y->get_status();

    unless ($status->OK()) {
	print $status->status(), ", ", $status->message(), "\n";
	return;
    }
    
    printf "%-15s - %s\n", 'Name', $entity;

    printf "%-15s - ", "Permissions";
    printf "Edit: %s / ", $eobj->can_write()?'Yes':'No';
    printf "Expire: %s / ", $eobj->can_expire()?'Yes':'No';
    printf "Create instances: %s\n", $eobj->can_instanciate()?'Yes':'No';

    # Add multiline support.
    my @instances = $eobj->instances();
    printf "%-15s - ", "Instances";
    if (@instances) {
	print join (", ", map { nameify( $_ ) } @instances), "\n";
    } else {
	print "NULL\n";
    }    
    
    my @props = $eobj->properties();

    if (@props) {
	print "Properties\n";
	for my $prop (@props) {
	    my $prop_orig_entity = $prop->entity();
	    my $source = $prop_orig_entity->id();
	    my $type = $prop->type();
	    printf "  %-13s - %-10s - %-7s%s\n",  nameify( $prop ), lc $prop->type(),
	      $prop->null()?'TRUE':'FALSE',
		$source ne $eobj->id()?" [$source]":'';
	}
    } else {
	printf "%-15s - NULL\n", "Properties";
    }

    my @rels = $eobj->relations();
    
    if (@rels) {
	print "Relations\n";
	for my $o (@rels) {
	    my $orig_entity = $o->entities();
	    my ($lval, $rval) = $o->entities();
	    printf "  %-13s - %10s<->%-10s\n", nameify( $o ), $lval->id(), $rval->id();
	}
    } else {
	printf "%-15s - NULL\n", "Relations";
    }

    my @descendants;
    @descendants = $eobj->descendants() if $eobj->parent();
    
    if( @descendants ) {
	print "Descendants\n";
	for my $d (@descendants) {
	    printf "  %-13s\n", $d;
	}
    }
    
    display_tick( $eobj );
}

sub entity_create {
    my($entity_command, $create_command, $entity) = @_;
    if ($start || $stop) {
	print "Unable to create entities while in non-current state.  You might wish to do 'set temporal current'.";
	return;
    }
    
    my $e = $y->get_entity( $entity );
    
    print "'$entity' already exists.\n" and return if $e;

    my $eobj = $y->define_entity( $entity );
    if( $y->get_status()->OK() ) {
	print "'$entity' created.\n";
    } else {
	print $y->get_status()->message, "\n";
    }
}

sub entity_expire {
    my($entity_command, $expire_command, $entity) = @_;
    if ($start || $stop) {
	print "Unable to expire entities while in non-current state.  You might wish to do 'set temporal current'.";
	return;
    }
    
    my $e = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $e;
    $e->expire();

    if( $y->get_status()->OK() ) {
	print "'$entity' expired.\n";
    } else {
	print $y->get_status()->message, "\n";
    }
}

sub entity_search {
    my ($entity_command, $search_command, $entity, $property, $value) = @_;

    my ($ekey, $tstart, $tstop) = extract_temporality( $entity );
    my $eobj = $y->get_entity( $ekey, populate_times( $tstart, $tstop ) );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my $pkey;
    ($pkey, $tstart, $tstop) = extract_temporality( $property );
    my $pobj = $eobj->get_property( $pkey, populate_times( $tstart, $tstop ) );
    print "'$property', no such property in '$entity'.\n" and return unless $pobj;

    my @hits = $eobj->find_instances_by_property_value( key => $pkey, value => $value );

    my $status = $y->get_status();
    print $status->message(), "\n" unless $status->OK();

    if (@hits) {
	printf "%-15s - %s\n", $ekey, $pkey;
	for my $hit (@hits) {
	    printf "%-15s - %s\n", $hit->id(), $hit->property( $pkey ) || '';
	}
    } else {
	print "No hits.\n";
    }
}


# Property interface
sub property_create {
    my($property_command, $create_command, $entity, $property, $type, $nullp) = @_;
    if ($start || $stop) {
	print "Unable to create properties while in non-current state.  You might wish to do 'set temporal current'.";
	return;
    }

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    $nullp = $nullp eq "true" ? 1 : 0;

    $y->define_property( $eobj, $property, type => $type, nullp => $nullp );
    
    print $y->get_status()->message, "\n";
}

sub property_info {
    my($property_command, $info_command, $entity, $property) = @_;
    my ($ekey, $pkey, $tstart, $tstop);
    ($ekey, $tstart, $tstop) = extract_temporality( $entity );
    
    my $eobj = $y->get_entity( $ekey, populate_times( $tstart, $tstop ) );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    ($pkey, $tstart, $tstop) = extract_temporality( $property );
    my $pobj = $eobj->get_property( $pkey, populate_times( $tstart, $tstop ) );
    print "'$property', no such property in '$entity'.\n" and return unless $pobj;
    
    printf "%-15s - %s\n", 'Full name', "$ekey:$pkey";

    printf "%-15s - ", "Permissions";
    printf "Expire: %s\n", $pobj->can_expire()?'Yes':'No';
    
    printf "%-15s - %s\n%-15s - %s\n", 'Type', lc $pobj->type(), 'Null legal', $pobj->null()?'TRUE':'FALSE';    
    display_tick( $pobj );
}

sub property_expire {
    my($property_command, $info_command, $entity, $property) = @_;
    print "Unable to expire properties while in non-current state.  You might wish to do 'set temporal current'." and return if $start || $stop;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $pobj = $eobj->get_property( $property );
    print "'$property', no such property in '$entity'.\n" and return unless $pobj;
    
    $pobj->expire();
    print $status->message(), "\n";
}

sub property_types {
    print join( ", ", sort $y->property_types() ), "\n";
}

# Instance interface
sub instance_info {
    my ($instance_command, $info_command, $entity, $instance) = @_;
    my ($ekey, $ikey, $tstart, $tstop);

    ($ekey, $tstart, $tstop) = extract_temporality( $entity );
    my $eobj = $y->get_entity( $ekey, populate_times( $tstart, $tstop ) );    
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    ($ikey, $tstart, $tstop) = extract_temporality( $instance );
    my $iobj = $eobj->fetch( $ikey, populate_times( $tstart, $tstop) );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;

    print "$entity / $instance:\n";

    printf "%-15s - ", "Permissions";
    printf "Edit: %s / ", $iobj->can_write()?'Yes':'No';    
    printf "Expire: %s\n", $iobj->can_expire()?'Yes':'No';    
    
    my @props = $eobj->properties();
    printf "%-15s - %s\n", 'Property', 'Value' if @props;
    for my $prop (@props) {
	my $value = $iobj->get( $prop ) || '';
	my ($r, $w, $e)  = ('r',
			    $iobj->can_write_value( $prop )?'w':'',
			    $iobj->can_expire_value( $prop )?'e':'');
	if (length $value > 65) {
	    $value = substr( $value, 0, 60 ) . '[ ... ]';
	}
	
	printf "  %-13s - %s ($r$w$e)\n", $prop->id(), $value;
    }

    display_tick( $iobj );
}

sub instance_expire {
    my ($instance_command, $info_command, $entity, $instance) = @_;
    print "Unable to expire instances while in non-current state.  You might wish to do 'set temporal current'." and return if $start || $stop;
    
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my $iobj = $eobj->fetch( $instance );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;
    
    $iobj->expire();
    if ($status->OK()) {
	print "Instance " . $iobj->id() . " in " . $eobj->id() . " has been expired\n";
    } else {
	print $status->message(), "\n";
    }
}

sub instance_edit {
    my ($instance_command, $info_command, $entity, $instance, $property) = @_;
    print "Unable to edit instances while in non-current state.  You might wish to do 'set temporal current'." and return if $start || $stop;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $iobj = $eobj->fetch( $instance );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;

    my $pobj = $eobj->property_exists( $property );
    print "'$property', no such property in $entity.\n" and return unless $pobj;

    my $old_value = $iobj->property( $property ) || '';
    my $new_value = $term->readline(" New value for '$property' ($old_value) > ");
    my $retval = $iobj->property( $property, $new_value );

    if (! $status->OK() || ! defined $retval) {
	print "Setting the value of '$property' in '$instance' failed: " . 
	  $status->message() . "\n";
    }
}

sub instance_create {
    my ($instance_command, $create_command, $entity, $instance_name) = @_;
    print "Unable to create instances while in non-current state.  You might wish to do 'set temporal current'." and return if $start || $stop;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my $iobj = $eobj->fetch( $instance_name );
    print "'$instance_name' already exists in $entity.\n" and return if $iobj;
    
    $iobj = $eobj->create( $instance_name );

    if (! $status->OK()) {
	print $status->message(), "\n";
    } else {
	print "'$instance_name' created in '$entity'.\n";
    }
}

# This doesn't work, we only get one item back from fetch(), we
# probably need to look at _get_in_time in Instance.pm.  Also, needs
# temporality fixing, this is mucho currento.
sub instance_history {
    my ($instance_command, $info_command, $full_command, $entity, $instance) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my @iobjs = $eobj->fetch( $instance, time => { start => 0, stop => undef, format => 'tick' } );
    print "'$instance', no such instance in $entity.\n" and return unless @iobjs;
    my $entries = scalar @iobjs || 0;
    
    print "$entity / $instance (full history, $entries ", $entries > 1?'entries':'entry', "):\n";
    
    my @props = $eobj->properties( time => { start => 0, stop => undef, format => 'tick' } );
    my (@lines);    

    # Hack due to noise from tempoarlity, see ticket 16.
    my %unique_props;
    for my $p (@props) {
	$unique_props{$p->id()} = $p;
    }
    
    my %maxwidth;
    $maxwidth{start} = $maxwidth{stop} = 6; # default, will be overwritten if length is longer.
    for my $iobj (@iobjs) {
	my %currentline;
	for my $prop ('start', 'stop', values %unique_props) {
	    my $propname = ref $prop?$prop->id():$prop;
	    my $value;

	    if ($prop eq 'start') {
		$value = $iobj->start() || 0;
	    } elsif ($prop eq 'stop') {
		$value = $iobj->stop();
	    } else {
		$value = $iobj->get( $propname ) || '';
	    }

	    next unless $value;
            my $length = length $value;
            $maxwidth{$propname} ||= 0;
            $maxwidth{$propname} = $length if $length > $maxwidth{$propname};
	    $currentline{$propname} = $value;
	}
	push @lines, \%currentline;
    }

    my @maxwidth;
    my @header;
    for my $prop ('start', 'stop', values %unique_props) {
	my $propname = ref $prop?$prop->id():$prop;
	my $w = $maxwidth{$propname} || 1;
	push @header, sprintf "%-${w}s", $propname;
    }
    print join( ' | ', @header ), "\n";
    
    for my $l (@lines) {
	my @l;
	for my $prop ('start', 'stop', values %unique_props) {
	    my $propname = ref $prop?$prop->id():$prop;
	    my $w = $maxwidth{$propname} || 1;
	    push @l, sprintf "%-${w}s", $l->{$propname} || '';
	}
	print join( ' | ', @l ), "\n";
    }
    
}

sub instance_property_history {
    my($instance_command, $history_command, $prop_command, $entity, $instance, $property) = @_;
    my ($ekey, $ikey, $pkey, $tstart, $tstop);

    ($ekey, $tstart, $tstop) = extract_temporality( $entity );
    my $eobj = $y->get_entity( $ekey, populate_times( $tstart, $tstop ) );    
    print "'$entity', no such entity.\n" and return unless $eobj;

    ($ikey, $tstart, $tstop) = extract_temporality( $instance );
    my $iobj = $eobj->fetch( $ikey, populate_times( $tstart, $tstop ));
    print "'$instance', no such instance.\n" and return unless $iobj;

    ($pkey, $tstart, $tstop) = extract_temporality( $property );
    my %changes = $iobj->property_history($pkey);
    for my $tick ( keys %changes ) {
	print "* $tick [$changes{$tick}]\n";
    }
}

# Relations
sub relation_entities {
    my ($relation_command, $create_command, $entity1, $entity2) = @_;
    
    print "Identical entities, aborting.\n" and return if $entity1 eq $entity2;

    my $e1 = $y->get_entity( $entity1 );
    print "Unable to find entity '$e1'\n" and return unless $e1;

    my $e2 = $y->get_entity( $entity2 );
    print "Unable to find entity '$e2'\n" and return unless $e2;
    
    my $r = $y->define_relation( $e1, $e2 );
    if (! $status->OK()) {
	print $status->message(), "\n";
    } else {
	my $lab = $r->id();
	print "Entities '$entity1' and '$entity2' related, with the label '$lab'.\n";
    }
}

sub relation_instances {
    my ($relation_command, $create_command, $label, $i1, $i2) = @_;
    
    my $rel = $y->get_relation( $label );
    print $status->message(), "\n" and return unless $status->OK();

    my ($e1o, $e2o) = $rel->entities();
    
    my $i1o = $e1o->fetch( $i1 );
    print $status->message(), "\n" and return unless $i1o;
    
    my $i2o = $e2o->fetch( $i2 );
    print $status->message(), "\n" and return unless $i2o;

    my $link = $rel->link( $i1o, $i2o );
    print $status->message(), "\n" and return unless $status->OK();
    print "'$i1' is bound to '$i2' via '$label'\n";
}

sub relation_list {
    my ($relation_command, $list_command) = @_;

    my @relations;
    for my $r ( $y->relations() ) {
	my $w = $r->can_write() ? 'w' : '';
	my $e = $r->can_expire() ? 'e' : '';

	push( @relations, join(" ", $r->id(), "(r$w$e)") );
    }

    print join( ", ", @relations ), "\n";
}

sub relation_info {
    my ($relation_command, $info_command, $label) = @_;

    my($rkey, $tstart, $tstop) = extract_temporality( $label );
    my $rel = $y->get_relation( $rkey, populate_times( $tstart, $tstop ) );    
    print $status->message(), "\n" and return unless $status->OK();

    print "$label\n";

    printf "%-15s - ", "Permissions";
    printf "Edit: %s / ", $rel->can_write()?'Yes':'No';
    printf "Expire: %s\n", $rel->can_expire()?'Yes':'No';
    
    my ($e1o, $e2o) = $rel->entities();
    my @pairs = $rel->participants();
    
    if (@pairs) {
	print "Participants\n";
	for my $p (@pairs) {
	    my ($li, $ri) = @$p;
	    printf "  %20s <-> %-20s\n", $li->id(), $ri->id();
	}
    }
    
}

sub relation_expire {
    my($relation_command, $expire_command, $label) = @_;

    my $rel = $y->get_relation( $label );
    print $status->message(), "\n" and return unless $status->OK();

    $rel->expire();
    print $status->message(), "\n";
}

# Tick interface
sub tick_info {
    my ($tick_command, $info_command, $tick) = @_;

    my @ticks;
    my @sequences = split m/,/, $tick;
    
    for my $s (@sequences) {
	if ($s =~ /^(\d+)-(\d+)/) {
	    push @ticks, $y->get_ticks( start => $1, stop => $2 );
	} elsif ($s =~ /^(\d+)$/) {
	    push @ticks, $y->get_tick( $1 );
	} else {
	    print "Unable to parse input, '$s', skipping.\n";
	}
    }

    print "'$tick', no such tick.\n" and return unless $ticks[0];
    
    for my $t (@ticks) {
	print "Tick ", $t->{id}, ":\n";
	printf "%20s - %s\n", 'Timestamp', $t->{stamp};
	printf "%20s - %s\n", 'Committer', $t->{committer};

	my $eventstring = 'Event';
	for my $e (@{$t->{events}}) {
	    printf "%20s - %s", $eventstring, $e->{string};
	    if ($e->{stop}) {
		print " (expired tick " . $e->{stop} . ")\n";
	    } else {
		print " (still valid)\n";
	    }
	    $eventstring = '';
	}	
    }
    print "\n";
}

sub tick_current {
    my ($tick_command, $current_command) = @_;

    my $tickid = $y->current_tick();
    print "$tickid\n";
}

sub ticks_in_time {
    my ($tick_command, $info_command, $time) = @_;
    my ($from, $to) = split / to /, $time;

    my @ticks = $y->get_ticks_by_time( $from, $to );
    
    print "No ticks for the given time.\n" and return unless @ticks;

    printf "%10s - %20s - %s\n", 'Tick', 'Timestamp', 'Committer';
    for my $tick (@ticks) {
	printf "%10d - %20s - %s\n", $tick->{id}, $tick->{stamp}, $tick->{committer};
    }
    
}

# Cache interface
# This makes some assumptions about Storage, but meh.
sub cache_info {
    my ($cache_command, $type) = @_;
    my $cache = $y->storage()->{cache};    
    
    for my $type (sort keys %$cache) {
	print "$type\n";
	for my $key (sort keys %{$cache->{$type}}) {
	    printf " %45s - %s\n", $key, $cache->{$type}->{$key};
	}
	print "\n";
    }    
}

# Role interface
sub role_info {
    my ($role_command, $info_command, $rolename) = @_;
    my $robj = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $robj;
    
    print "${rolename}:\n";
    printf "%20s - %s\n", 'Description', $robj->description() || '';
    printf "%20s - %s\n", 'Members', join ", ", map { $_->id() } $robj->members();
}

sub role_description {
    my($role_command, $desc_command, $role) = @_;
    
    my $robj = $y->get_role( $role );
    print "'$role', no such role.\n" and return unless $robj;

    my $desc = $term->readline(" New description for role '$role' > ");
    print "'$desc' is invalid.\n" and return unless defined $desc;

    $robj->description( $desc );
    print "New description for '$role' is '$desc'.\n";
}

sub role_create {
    my ($role_command, $create_command, $rname) = @_;

    print "'$rname', already taken.\n" and return if $y->get_role( $rname );

    my $desc = $term->readline(" Description > ");
    print "'$desc' is invalid.\n" and return unless defined $desc;

    my $robj = $y->define_role( $rname );
    $robj->description( $desc );
    print "Role '$rname' created.\n";
}

sub role_grant {
    my $role_command  = shift;

    grant_revoke( @_ );
}

sub role_revoke {
    my $role_command   = shift;
    
    grant_revoke( @_ );
}

sub grant_revoke {
    my $operation = shift;
    my $privilege = shift;
    my $role      = shift;
    my $type      = shift;

    my %tag = (
	read   => 'r',
	write  => 'w',
	modify => 'm',
    );
    print "'$privilege', no such privilege.\n" and return unless $tag{$privilege};

    my $robj = $y->get_role( $role );
    print "'$role', no such role.\n" and return unless $robj;

    my $o;
    if( $type eq "entity" ) {
	my $entity = shift;

	$o = $y->get_entity( $entity );
	print "'$entity', no such entity.\n" and return unless $o;
    } elsif( $type eq "instance" ) {
	my $entity   = shift;
	my $instance = shift;

	$o = $y->get_instance( $entity, $instance );
	print "'$instance', no such instance.\n" and return unless $o;
    } elsif( $type eq "relation" ) {
	my $label = shift;

	$o = $y->get_relation( $label );
	print "'$label', no such relation.\n" and return unless $o;
    } elsif( $type eq "property" ) {
	my $entity   = shift;
	my $property = shift;

	$o = $y->get_property( $entity, $property );
	print "'$property', no such property.\n" and return unless $o;
    } elsif( $type eq "iproperty" ) {
	my $entity   = shift;
	my $instance = shift;
	my $property = shift;

	my $iobj = $y->get_instance( $entity, $instance );
	print "'$instance', no such instance.\n" and return unless $iobj;

	# FIX: objectify $o (instance property?)
    }

    if( $operation eq "grant" ) {
	$robj->grant( $tag{$privilege} => $o );
	print "Granted role '$role' $privilege privileges to ", $o->id(), "\n"; 
    } elsif( $operation eq "revoke" ) {
	$robj->revoke( $tag{$privilege} => $o );
	print "Revoked role '$role' $privilege privileges to ", $o->id(), "\n"; 
    } else {
	print "'$type', no such type.\n";
	return;
    }

}

sub ygg_search {
    my ($search_command, $search_string) = @_;
    
    my ($entities, $instances, $properties, $relations) = $y->search( $search_string );
    
    unless ($status->OK()) {
	print $status->message(), "\n";
	return;
    }
    
    if (@$entities) {
	print "Matching entities:\n";
	for my $e (@$entities) {
	    print " - ", $e->id(), "\n";
	}
    } 
    
    if (@$instances) {
	print "Matching instances:\n";
	for my $i (@$instances) {
	    print " - ", $i->id(), " (", $i->entity()->id(), ")\n";
	}
    } 
    
    if (@$properties) {
	print "Matching properties:\n";
	for my $p (@$properties) {
	    print " - ", $p->id(), " (", $p->entity()->id(), ")\n";
	}
    } 

    if (@$relations) {
	print "Matching relations:\n";
	for my $r (@$relations) {
	    my ($lval, $rval) = $r->entities();
	    print " - ", $r->id(), " (", $lval->id(), " <-> ", $rval->id(), ")\n";
	}
    } 
}

sub transaction_log {
    my @entries = $y->transaction_stack_get();
    print "Transaction stack empty.\n" and return unless @entries;
    
    print "Transaction stack:\n";
    for my $entry (@entries) {
	printf " %05d | %-7s | %s\n", $entry->id(), $entry->path(), join( ', ', $entry->get_commit_log());
	for my $engine ($entry->get_engine_log()) {
	    print "       | $engine\n";
	}
    }
    $y->transaction_stack_clear();
}

sub populate_times {
    my ($tstart, $tstop) = @_;

    return unless $tstart;
    return time => { start => $tstart, stop => $tstop, format => 'tick' };
}

sub extract_temporality {
    my $input = shift;
    my ($key, $timeslice) = split /(?<=[^:]):(?=[^:])/, $input;
    
    if ($timeslice) {
	my ($temporal_start, $temporal_stop) = split /-/, $timeslice;
	return ($key, $temporal_start, $temporal_stop);
    } else {
	return $key;
    }
    
}

# Helper stuff.
sub display_tick {
    my $obj  = shift;
    my $tick = $y->get_tick( $obj->realstart() );
    printf "%-15s - %s (%d) / %s\n", 'Created', $tick->{stamp}, $obj->realstart(), $tick->{committer};

    if ($stop && $obj->realstop()) {
	$tick = $y->get_tick( $obj->realstop() );
	printf "%-15s - %s (%d) / %s\n", 'Expired', $tick->{stamp}, $obj->realstop(), $tick->{committer};
    }
    
}

sub nameify {
    my $obj = shift;
    
    if ($obj->stop()) {
	return $obj->id() . ':' . $obj->realstart() . '-' . $obj->stop();
    } else {
	return $obj->id();
    }
}

# Yggdrasil expand interface.
sub expand_label {
    return map { nameify( $_ ) } $y->relations( populate_times( $start, $stop ) );	
}

sub expand_user {
    return $y->usernames();
}

sub expand_role {
    return $y->rolenames();
}

sub expand_entity {
    return map { nameify( $_ ) } $y->entities( populate_times( $start, $stop ) );	
}

sub expand_instance {
    my( $instance, $entity ) = @_;

    my ($ekey, $tstart, $tstop) = extract_temporality( $entity );
    my $eobj = $y->get_entity( $ekey, populate_times( $tstart, $tstop ) );
    return unless $eobj;

    return map { nameify( $_ ) } $eobj->instances();    
}

sub expand_instance_relation {
    my( $side, $instance, $relation ) = @_;

    my $rel = $y->get_relation( $relation );
    my ($left, $right) = $rel->entities();

    if ($side eq 'l') {
	return map { $_->id() } $left->instances();	
    } else {
	return map { $_->id() } $right->instances();
    }
}

sub expand_instance_relation_left {
    my( $left, $relation ) = @_;
    return expand_instance_relation( 'l', $left, $relation );
}

sub expand_instance_relation_right {
    my( $right, $left, $relation ) = @_;
    return expand_instance_relation( 'r', $right, $relation );
}

sub expand_entity_property {
    my( $prop, $entity ) = @_;

    my ($ekey, $tstart, $tstop) = extract_temporality( $entity );
    my $eobj = $y->get_entity( $ekey, populate_times( $tstart, $tstop ) );
    return unless $eobj;

    return map { nameify( $_ ) } $eobj->properties();    
}

sub expand_instance_property {
    my( $prop, $instance, $entity ) = @_;

    return expand_entity_property( $prop, $entity );
}


sub expand_property_type {
    return $y->property_types();
}

sub completion {
    my $word  = shift;
    my $line  = shift;
    my $start = shift;
    my $top   = shift;
    my $path  = shift;

    $attribs->{filename_completion_desired} = 1;

    # Add to line what has previously been written
    $line = join(" ", @$path, $line);

    # All "words" before the one we are writing 'now'
    my @commands = lineparser( $line );

    # add the word we are about to write now (if it's empty)
    push( @commands, $word ) if $word !~ /\S/;

    for( my $i=0; $i<@commands; $i++ ) {
	my $c = $commands[$i];

	# reached end of command line
	return if ref $top eq 'CODE';

	if (exists $top->{$c}) {
	    # static command part
	    # "user", "info" etc.
	    $top = $top->{$c};
	} elsif ( $i < $#commands ) {
	    # dynamic command part
	    # only go to next level if a whole word has been written
	    # and we are currently writing the next one
	    my( $expander ) = grep { $_ !~ /^_help$/ } grep { /^_/ } keys %$top;
	    $top = $top->{$expander} if $expander;
	}
    } 

    return 
	map {
	    if ($cmd_handler{$_}) {
		# Grab command handlers
		$cmd_handler{$_}->( reverse @commands );
	    } elsif ($_ =~ /^_/) {
		# Strip _-commands, like _desc as well.
	    } else {
		# Otherwise, return the key raw.
		$_;
	    }
	} keys %$top if ref $top eq 'HASH';
    
    return;
}

# wrapper around shellwords that can handle unclosed quotes
sub lineparser {
    my $line = shift;
    
    return unless length $line;

    my @r = shellwords( $line );
    unless( @r ) {
	my $closed = $line . '"';
	@r = shellwords( $closed );
    }

    unless( @r ) {
	my $closed = $line . "'";
	@r = shellwords( $closed );
    }

    return grep { defined && length } @r;
}

sub _read_password {
    my ($tries, $counter) = (0, 0);
    my @pass = ('x', 'y');
    
    while ($tries < 3 && $pass[0] ne $pass[1]) {
	print "Passwords didn't match, try again.\n" if $tries && $counter == 0;
	printf "%s: ", $counter==0?"Password":'Repeat password';
	system("stty -echo");
	chop($pass[$counter] = <>);
	print "\n";
	system("stty echo");
	return $pass[0] if $pass[0] eq $pass[1];
	if ($counter == 1) {
	    $counter = 0;
	    $tries++;
	} else {
	    $counter++;
	}
    }
    return undef;
}

__DATA__
ycontrol is a command line interface to directly manipulate Yggdrasil
structures.
  
For help with ycontrol operation, type 'help' at the command prompt, most
operators are documented directly.  If you have any further questions, 
please see the Yggdrasil documentation.

