#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Term::ReadLine;
use Text::ParseWords;

use Crypt::GeneratePassword;

use Yggdrasil;

my ($dbuser, $password, $host, $port, $db, $engine) =
  ($ENV{YGG_USER}, $ENV{YGG_PASSWORD}, $ENV{YGG_HOST}, $ENV{YGG_PORT}, $ENV{YGG_DB}, $ENV{YGG_ENGINE});

my $y = new Yggdrasil();
my $status = $y->get_status();

$y->connect( 
	    user      => $dbuser,
	    password  => $password,
	    host      => $host,
	    port      => $port,
	    db        => $db,
	    engine    => $engine,
	   );

die $status->message() unless $status->OK();

my $iam = $y->login();
my @roles = $iam->get_cached_member_of();

die $status->message() unless $status->OK();

my $term = new Term::ReadLine 'ycontrol';
my $attribs = $term->Attribs;
my $OUT = $term->OUT || \*STDOUT;

my %cmd;
%cmd = (
    help => \%cmd,

    user => {
	_help => "User tools",

	info  => {
	    _help => "Show information about a user",
	    _user => \&user_info,
	},

	password => {
	    _help => "Change user password",
	    _user => \&user_password,
	},

	name => {
	    _help => "Change user full name",
	    _user => \&user_fullname,
	},

	create => {
	    _help => "Create new user",
	    _user => \&user_create,
	},

	delete   => {
	    _help => "Delete a user",
	    _user => \&user_delete,
	},

	role => {
	    _help => "User role membership tools", 
	    add   => {
		_help => "Add user to role",
		_user => {
		    _role => \&user_role_add,
		},
	    },
	    remove => {
		_help => "Remove user from role",
		_user => {
		    _role => \&user_role_remove,
		},
		
	    },
	},
    },
    
    role => {
	_help => "Role tools",

	info  => {
	    _help => "Show information about a role",
	    _role => \&role_info,
	},
	
	description => {
	    _help => "Change role description",
	    _role => \&role_description,
	},

	grant => {
	    _help => "Grant role privileges for an entity",

	    read   => {
		_help => "Grant role read privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		}
	    },

	    write  => {
		_help => "Grant role write privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		},
	    },

	    create => {
		_help => "Grant role create privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		},
	    },

	    delete => {
		_help => "Grant role delete privileges for an entity",
		_role => {
		    _entity => \&role_grant,
		},
	    },
	},

	revoke => {
	    _help => "Revoke role privileges for an entity",

	    read   => {
		_help => "Revoke role read privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		}
	    },

	    write  => {
		_help => "Revoke role write privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		},
	    },

	    create => {
		_help => "Revoke role create privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		},
	    },

	    delete => {
		_help => "Revoke role delete privileges for an entity",
		_role => {
		    _entity => \&role_revoke,
		},
	    },

	}
    },
    
    entity => {
	_help => "Entity tools",

	info  => {
	    _help   => "Show information about an entity",
	    _entity => \&entity_info,
	},

	create => {
	    _help   => "Create new entity",
	    _entity => \&entity_create,
	},
    },

    property => {
	_help => "Property tools",
	
	create => {
	    _help   => "Create a property",
	    _entity => {
		# This is just a noop, but it works better than letting
		# an existing property be expanded.
		_INPUT_ => {
		    _property_type => \&property_create,
		},
	    },
	},
    },

    instance => {
	_help => "Instance tools",

	info  => {
	    _help   => "Show information about an instance",
	    _entity => {
		_instance => \&instance_info,
	    },
	},
	set => {
	    _help   => "Edit the property of an instance",
	    _entity => {
		_instance => {
		    _instance_property => \&instance_edit,
		},
	    },
	},
	history => {
	    _help   => "Instance history",
	    _entity => {
		_instance => \&instance_history,
	    },
	},
    },
    
    relation => {
	_help => "Relation tools",
    },
    quit     => sub { exit },
    exit     => sub { exit },
);


my %cmd_handler = (
    _user => \&expand_user,
    _role => \&expand_role,
    
    _entity   => \&expand_entity,
    _instance => \&expand_instance,

    _instance_property => \&expand_instance_property,
    _entity_property   => \&expand_entity_property,
    
    _property_type => \&expand_property_type,
    );


my $prompt = " > ";
my @cmd_path = ();
$attribs->{completion_function} = sub { completion(@_, \%cmd, \@cmd_path) };

while ( defined (my $input = $term->readline($prompt)) ) {
    chomp $input;

    if( $input !~ /\S/ ) {
	@cmd_path = ();
	next;
    }
    
    # Add to line what has previously been written
    $input = join(" ", @cmd_path, $input);

    my @this_path;
    my $context = \%cmd;
    for my $key ( shellwords($input) ) {
	if (exists $context->{$key}) {
	    # static command part
	    # "user", "info" etc.
	    $context = $context->{$key};
	    push( @this_path, $key );
	} else {
	    # dynamic command part
	    my( $expander ) = grep { $_ !~ /_help/ } grep { /^_/ } keys %$context;
	    if ( $expander ) {
		$context = $context->{$expander};
		push( @this_path, $key );
	    }
	}
    }

    @cmd_path = @this_path;

    if( @cmd_path && $cmd_path[0] eq "help" ) {
	# display help
	shift @cmd_path while @cmd_path && $cmd_path[0] eq "help";
	help( $context, \@cmd_path );
	@cmd_path = ();
    } elsif (ref $context eq 'CODE') {
	# Reached end of command line
	$context->( @cmd_path );
	@cmd_path = ();
    }
    
} continue {
    # Set prompt
    $prompt = join(" ", @cmd_path) . " > ";
}

sub help {
    my $top  = shift;
    my $path = shift;

    if( ref $top ne "HASH" ) {
	print "No help for '", join(" ", @$path), "'\n";
	return;
    }

    my $prefix = join(" ", @$path);
    for my $key ( sort keys %$top ) {
	if( $key =~ /^_help$/ ) {
	    printf( "%-25s - %s\n", $prefix, $top->{$key} );
	}

	next if $key =~ /^_/;

	my $help = ref $top->{$key} eq "HASH" && exists $top->{$key}->{_help};
	$help = $help ? $top->{$key}->{_help} : '';

	printf( "%-25s - %s\n", join(" ", $prefix, $key), $help );
    }
}

# Commands
# User interface.
sub user_info {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    printf "%20s - %s\n", 'Username', $username;
    printf "%20s - %s\n", 'Full name', $user->fullname() || '';
    printf "%20s - %s\n", 'Session', $user->session() || '';
    printf "%20s - %s\n", 'Password', $user->password() || '';
    printf "%20s - %s\n", 'Roles', join ", ", map { $_->name() } $user->member_of();
}

sub user_password {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    my $pass = Crypt::GeneratePassword::word( 6, 10 );
    $user->password( $pass );
    print "New password for '$username' is '$pass'.\n";
}

sub user_fullname {
    my ($user_command, $info_command, $username) = @_;

    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;

    my $name = $term->readline(" New full name for '$username' > ");
    print "'$name' is invalid.\n" and return unless defined $name;

    $user->fullname( $name );
    print "New full name for '$username' is '$name'.\n";
}

sub user_role_add {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;

    $role->add( $user );
    print "Added the user '$username' to the role '$rolename'.\n";   
}

sub user_role_remove {
    my ($user_command, $role_word, $role_add, $username, $rolename) = @_;
    my $user = $y->get_user( $username );
    print "'$username', no such user.\n" and return unless $user;
    
    my $role = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $role;

    $role->remove( $user );
    print "Removed the user '$username' from the role '$rolename'.\n";   
}

sub user_create {
    my ($user_command, $create_command, $uname) = @_;

    print "'$uname', already taken.\n" and return if $y->get_user( $uname );

    my $uobj = $y->define_user( $uname );
    
    my $name = $term->readline(" Full name > ");
    print "'$name' is invalid.\n" and return unless defined $name;
    $uobj->fullname( $name );
    my $pass = Crypt::GeneratePassword::word( 6, 10 );
    $uobj->password( $pass );
    print "'$uname' created with password '$pass'.\n";
}

sub user_delete {
    my($user_command, $delete_command, $uname) = @_;

    my $uobj = $y->get_user( $uname );
    print "'$uname' does not exist.\n" and return unless $uobj;

    print "Not implemented\n";
}

# Entity interface
sub entity_info {
    my ($entity_command, $info_command, $entity) = @_;
    my $eobj = $y->get_entity( $entity );

    print "'$entity', no such entity.\n" and return unless $eobj;
    
    printf "%15s - %s\n", 'Name', $entity;

    # Add multiline support.
    print "Instances:\n";
    printf "  %s\n", join ", ", map { $_->id() } $eobj->instances();

    print "Properties:\n";
    printf "  %-13s - %5s - %s\n", 'Name', 'Null?', 'Type';
    for my $prop ($eobj->properties()) {
	my $type = $prop->type();
	printf "  %-13s - %5s - %s\n",  $prop->name(), $prop->null()?'TRUE':'FALSE', $prop->type();
    }
}

sub entity_create {
    my($entity_command, $create_command, $entity) = @_;

    print "'$entity' already exists.\n" and return if $y->get_entity( $entity );

    my $eobj = $y->define_entity( $entity );
    print "'$entity' created.\n";
}


# Property interface
sub property_create {
    my($property_command, $create_command, $entity, $property, $type) = @_;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my $pobj = $eobj->get_property( $property );
    print "'$property' already exists.\n" and return if $pobj;

    $y->define_property( $property, entity => $eobj, type => $type );
    
    if( $y->get_status()->OK() ) {
	print "'$property' created as $type\n";
    } else {
	print $y->get_status()->message, "\n";
    }
}

# Instance interface
sub instance_info {
    my ($instance_command, $info_command, $entity, $instance) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $iobj = $eobj->fetch( $instance );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;

    print "$entity / $instance:\n";
    
    my @props = $eobj->properties();
    printf "%-15s - %s\n", 'Property', 'Value' if @props;
    for my $prop (@props) {
	printf "%-15s - %s\n", $prop->name(), $iobj->get( $prop ) || '';
    }    
}

sub instance_edit {
    my ($instance_command, $info_command, $entity, $instance, $property) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;
    
    my $iobj = $eobj->fetch( $instance );
    print "'$instance', no such instance in $entity.\n" and return unless $iobj;

    my $pobj = $eobj->property_exists( $property );
    print "'$property', no such property in $entity.\n" and return unless $pobj;

    my $old_value = $iobj->property( $property ) || '';
    my $new_value = $term->readline(" New value for '$property' ($old_value) > ");
    my $retval = $iobj->property( $property, $new_value );

    if (! $status->OK() || ! defined $retval) {
	print "Setting the value of '$property' in '$instance' failed: " . 
	  $status->message() . "\n";
    }
}


# This doesn't work, we only get one item back from fetch(), we
# probably need to look at _get_in_time in Instance.pm.
sub instance_history {
    my ($instance_command, $info_command, $entity, $instance) = @_;
    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my $now = time;
    my @iobjs = $eobj->fetch( $instance, 0, $now );
    print "'$instance', no such instance in $entity.\n" and return unless @iobjs;
    
    print "$entity / $instance (full history):\n";
    
    my @props = $eobj->properties( 0, $now );
    my (@lines, %currentline);

    my %maxwidth;
    $maxwidth{start} = $maxwidth{stop} = 6; # default, will be overwritten if length is longer.
    for my $iobj (@iobjs) {
	%currentline = ();
	for my $prop ('start', 'stop', @props) {
	    my $propname = ref $prop?$prop->name():$prop;
	    my $value    = $iobj->get( $prop );
	    next unless $value;
            my $length = length $value;
            $maxwidth{$propname} ||= 0;
            $maxwidth{$propname} = $length if $length > $maxwidth{$propname};
	    $currentline{$propname} = $value;
	}
	push @lines, \%currentline;
    }

    my @maxwidth;
    my @header;
    for my $prop ('start', 'stop', @props) {
	my $propname = ref $prop?$prop->name():$prop;
	my $w = $maxwidth{$propname};
	push @header, sprintf "%-${w}s", $propname;
    }
    print join( ' | ', @header ), "\n";
    
    for my $l (@lines) {
	my @l;
	for my $prop ('start', 'stop', @props) {
	    my $propname = ref $prop?$prop->name():$prop;
	    my $w = $maxwidth{$propname};
	    push @l, sprintf "%-${w}s", $l->{$propname} || '';
	}
	print join( ' | ', @l ), "\n";
    }
    
}


# Role interface
sub role_info {
    my ($role_command, $info_command, $rolename) = @_;
    my $robj = $y->get_role( $rolename );
    print "'$rolename', no such role.\n" and return unless $robj;
    
    print "${rolename}:\n";
    printf "%20s - %s\n", 'Description', $robj->description() || '';
    printf "%20s - %s\n", 'Members', join ", ", map { $_->id() } $robj->members();
}

sub role_description {
    my($role_command, $desc_command, $role) = @_;
    
    my $robj = $y->get_role( $role );
    print "'$role', no such role.\n" and return unless $robj;

    my $desc = $term->readline(" New description for role '$role' > ");
    print "'$desc' is invalid.\n" and return unless defined $desc;

    $robj->description( $desc );
    print "New description for '$role' is '$desc'.\n";
}

sub role_grant {
    my($role_command, $grant_command, $privilege, $role, $entity) = @_;

    grant_revoke( $grant_command, $privilege, $role, $entity );
}

sub role_revoke {
    my($role_command, $revoke_command, $privilege, $role, $entity) = @_;
    
    grant_revoke( $revoke_command, $privilege, $role, $entity );
}

sub grant_revoke {
    my( $type, $privilege, $role, $entity ) = @_;

    my $robj = $y->get_role( $role );
    print "'$role', no such role.\n" and return unless $robj;

    my $eobj = $y->get_entity( $entity );
    print "'$entity', no such entity.\n" and return unless $eobj;

    my %tag = (
	read   => 'r',
	write  => 'w',
	create => 'c',
	delete => 'd',
    );
    print "'$privilege', no such privilege.\n" and return unless $tag{$privilege};

    if( $type eq "grant" ) {
	$robj->grant( $eobj, $tag{$privilege} );
	print "Granted role '$role' $privilege privileges to $entity\n"; 
    } elsif( $type eq "revoke" ) {
	$robj->revoke( $eobj, $tag{$privilege} );
	print "Revoked role '$role' $privilege privileges to $entity\n"; 
    } else {
	print "'$type', no such type.\n";
	return;
    }

}


# Yggdrasil expand interface.
sub expand_user {
    my $eobj = $y->get_entity( 'MetaAuthUser' );
    return map { $_->id() } $eobj->instances();
}

sub expand_role {
    my $eobj = $y->get_entity( 'MetaAuthRole' );
    return map { $_->id() } $eobj->instances();
}


sub expand_entity {
    return map { $_->name() } $y->entities();
}

sub expand_instance {
    my( $instance, $entity ) = @_;

    my $eobj = $y->get_entity( $entity );
    return unless $eobj;

    return map { $_->id() } $eobj->instances();    
}

sub expand_entity_property {
    my( $prop, $entity ) = @_;


    my $eobj = $y->get_entity( $entity );
    return unless $eobj;

    return map { $_->name() } $eobj->properties();    
}

sub expand_instance_property {
    my( $prop, $instance, $entity ) = @_;

    return expand_entity_property( $prop, $entity );
}


sub expand_property_type {
    return $y->property_types();
}


sub completion {
    my $word  = shift;
    my $line  = shift;
    my $start = shift;
    my $top   = shift;
    my $path  = shift;

    # Add to line what has previously been written
    $line = join(" ", @$path, $line);

    # All "words" before the one we are writing 'now'
    my @commands = shellwords( $line );

    # add the word we are about to write now (if it's empty)
    push( @commands, $word ) if $word !~ /\S/;

    for( my $i=0; $i<@commands; $i++ ) {
	my $c = $commands[$i];

	# reached end of command line
	return if ref $top eq 'CODE';

	if (exists $top->{$c}) {
	    # static command part
	    # "user", "info" etc.
	    $top = $top->{$c};
	} elsif ( $i < $#commands ) {
	    # dynamic command part
	    # only go to next level if a whole word has been written
	    # and we are currently writing the next one
	    my( $expander ) = grep { $_ !~ /^_help$/ } grep { /^_/ } keys %$top;
	    $top = $top->{$expander} if $expander;
	}
    } 

    return 
	map {
	    if ($cmd_handler{$_}) {
		# Grab command handlers
		$cmd_handler{$_}->( reverse @commands );
	    } elsif ($_ =~ /^_/) {
		# Strip _-commands, like _desc as well.
	    } else {
		# Otherwise, return the key raw.
		$_;
	    }
	} keys %$top if ref $top eq 'HASH';
    
    return;
}
