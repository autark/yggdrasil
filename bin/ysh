#!/usr/bin/perl

use strict;
use warnings;

use Term::ReadLine;
use Getopt::Long;

use FindBin qw($Bin);
use lib qq($Bin/../lib);

use Yggdrasil;

our $NAMESPACE = 'Ygg';

my ($user, $password, $host, $port, $db, $engine) =
  ($ENV{YGG_USER}, $ENV{YGG_PASSWORD}, $ENV{YGG_HOST}, $ENV{YGG_PORT}, $ENV{YGG_DB}, $ENV{YGG_ENGINE});

GetOptions(
	   "user=s"       => \$user,
	   "engine=s"     => \$engine,
	   "password=s"   => \$password,
	   "host=s"       => \$host,
	   "database=s"   => \$db,
	   "engine=s"     => \$engine,
	   "port=s"       => \$port,
	   "namespace=s"  => \$NAMESPACE,
	  );

new Yggdrasil(
	      user      => $user,
	      password  => $password,
	      host      => $host,
	      port      => $port,
	      db        => $db,
	      engine    => $engine,
	      namespace => $NAMESPACE,
	      admin     => 1,
	     );

my $term = new Term::ReadLine 'Yggdrasil Shell';
my $attribs = $term->Attribs;
my $prompt = "$NAMESPACE / $db : $engine @ $host: ";
my $OUT = $term->OUT || \*STDOUT;
my $isInstance = qr/^\$\[([^]]+)\]$/;

$attribs->{attempted_completion_function} = \&attempt_completion;
$attribs->{special_prefixes} = '$';

our( %INSTANCE );

# v define Yggdrasil::Entity '<Entity>';
# v define Yggdrasil::Relation Ygg::'<Entity>', Ygg::'<Entity>' ;

# v Yggdrasil::Entity->define( '<Entity>' );
# v Yggdrasil::Relation->define( '<Entity>', '<Entity>' );

# $<Instance>->property( '<Prop>', '<Value>' );
# $<Instance>->link( $<Instance> );
# $<Instance>->unlink( $<Instance> );
# $<Instance>->fetch_related( Ygg::'<Entity>' );
# $<Instance>->id();

# v get Ygg::<Entity> '<Instance>';
# v new Ygg::<Entity> '<Instance>';
# v properties Ygg::<Entity>;
# v search Ygg::<Entity> <Prop> => <Value>;
# v define Ygg::<Entity> '<Prop>', Type => '<Types>';

# Ygg::<Entity>->define( '<Prop>', Type => '<Types>' );
# Ygg::<Entity>->new( '<Instance>' );
# Ygg::<Entity>->search( <Prop> => <Value> );
# Ygg::<Entity>->properties;
# Ygg::<Entity>->get( '<Instance>' );




while ( defined (my $cmd = $term->readline($prompt)) ) {
    chomp $cmd;
    next unless $cmd =~ /\S/;

    my $original = $cmd;

    # $[...] is special syntax for $INSTANCE{...} which holds instance objects
    $cmd =~ s/\$\[([^]]+)\]/\$INSTANCE{"$1"}/g;

    my @res = do {
	no strict;
	no warnings;

	eval($cmd);
    };
    warn $@ if $@;

    # Somewhat pretty-print the result(s)
    unless( $@ ) {
	if( @res == 1 ) {
	    print $OUT convert($res[0]), "\n";
	} elsif( @res > 1 ) {
	    print $OUT "[", join(", ", map { convert($_) } @res), "]\n";
	} else {
	    print $OUT "\n";
	}
    }

    $term->addhistory($original);
}

# Simple function to prettify values. Esp. it handles instance objects
# by storing them in %INSTANCE as "key" => object for later misuse.
sub convert {
    my $data = shift;

    return "undef" unless defined $data;
    return $data unless ref $data;

    my $class = ref $data;
    if( $class =~ /^$NAMESPACE\::/ ) {
	my $id = $data->id();
	$INSTANCE{$id} = $data;
	return "$class(" . $data->id() . ")";
    }

    return $data;
}

sub reload {
    my $packagename = shift;
    my $file = "$Bin/../lib/$packagename";
    $file =~ s|::|/|g;
    $file .= '.pm';

    print " *** Reloading $packagename / $file\n";
    require "$file";
    import $packagename;
}

sub reload_all {
    for my $package (sort keys %INC) {
	next unless $package =~ /Yggdrasil/;
	$package =~ s/\.pm$//;
	reload( $package );
    }

}

# These are used by the expand_* functions
my $i = 0;
my @m = ();
my $entity;

sub attempt_completion {
    my $word = shift;
    my $line = shift;
    my $start = shift;
    my $stop  = shift;

    # Remove some noise in the current line
    $line =~ s/[,'"()>;=-]/ /g;

    # All "words" before the one we are writing 'now'
    my @pre = split ' ', substr( $line, 0, $start );

    # previous word written
    my $last = pop @pre;

    # Expand depending on context
    if( $last ) {
	# pre == 0 means current word is second word
	if( @pre == 0 ) {
	    if( $last eq "define" ) {
		# define SOMETHING
		return $term->completion_matches($word, \&expand_define );
	    } elsif( $last =~ /^(new|get|search|properties)$/ ) {
		# new SOMETHING, search SOMETHING, ...
		return $term->completion_matches($word, \&expand_entities_fq );
	    } elsif( $last =~ /^$NAMESPACE\::/ ) {
		# Ygg::Host -> SOMETHING
		return $term->completion_matches($word, \&expand_instance_class_methods );
	    } elsif( $last =~ /^Yggdrasil::/ ) {
		# Yggdrasil::* -> SOMETHING
		return 'define';
	    } elsif( $last =~ $isInstance ) {
		# $[...] -> SOMETHING
		return $term->completion_matches($word, \&expand_instance_methods );
	    }
	} 
	# pre == 1 means current word is third word
	elsif( @pre == 1 ) {
	    if( $last =~ /^Yggdrasil::/ ) {
		# define Yggdrasil::* SOMETHING
		return $term->completion_matches($word, \&expand_entities );
	    } elsif( $last =~ /^$NAMESPACE\::/ && $pre[-1] =~ /^(get|new)$/ ) {
		# get Ygg::Host SOMETHING
		return $term->completion_matches($word, \&expand_instances );
	    } elsif( $last =~ /^$NAMESPACE\::/ && $pre[-1] =~ /^(search|define)$/ ) {
		# search Ygg::Host SOMETHING
		$entity = $last;
		return $term->completion_matches($word, \&expand_properties );
	    } elsif( $pre[-1] =~ /^$NAMESPACE\::/ && $last =~ /^(get|new)$/ ) {
		# Ygg::Host->new( SOMETHING )
		return $term->completion_matches($word, \&expand_instances );
	    } elsif( $pre[-1] =~ /^$NAMESPACE\::/ && $last =~ /^(search|define)$/ ) {
		# Ygg::Host->search( SOMETHING )
		$entity = $pre[-1];
		return $term->completion_matches($word, \&expand_properties );
	    } elsif( $pre[-1] =~ $isInstance && $last eq "property" ) {
		# $[...]->property( SOMETHING )
		# fix, must know entity class of instance
		my $key = $1;
		my $instance = $INSTANCE{$key};
		$entity = ref $instance;
		return $term->completion_matches($word, \&expand_properties );
	    } elsif( $pre[-1] =~ $isInstance && $last =~ /^(un)?link$/ ) {
		# $[...]->link( SOMETHING )
		return $term->completion_matches($word, \&expand_instances );
	    } elsif( $pre[-1] =~ $isInstance && $last eq "fatch_related" ) {
		# $[...]->fetch_related( SOMETHING )
		return $term->completion_matches($word, \&expand_entities );
	    }
	} elsif( $last eq "Type" ) {
	    # Type => SOMETHING
	    return $term->completion_matches($word, \&expand_types );
	}
	
	# Catch-all - just expand to entities
	return $term->completion_matches($word, \&expand_entities );
    } else {
	# If this is the first word we're typing
	return $term->completion_matches($word, \&expand_start );
    }
    
}

sub expand_start {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add static words
	@m = qw/define Yggdrasil::Entity Yggdrasil::Relation new search properties get reload reload_all/;

	# Add entites with namespace
	push( @m, map { join("::", $NAMESPACE, $_) } Yggdrasil->entities() );

	# Add instance with $ in front
	push( @m, map { "\$[$_]" } keys %INSTANCE );
    } else { $i++; }

    return expand($word);
}

sub expand_define {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add static words
	@m = qw/Yggdrasil::Entity Yggdrasil::Relation/;

	# Add entities with namespace
	push( @m, map { join("::", $NAMESPACE, $_) } Yggdrasil->entities() );
    } else { $i++; }

    return expand($word);
}

sub expand_entities_fq {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add entities with namespace
	push( @m, map { join("::", $NAMESPACE, $_) } Yggdrasil->entities() );
    } else { $i++; }

    return expand($word);
}

sub expand_entities {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add entities
	@m = Yggdrasil->entities();
    } else { $i++; }

    return expand($word);
}

sub expand_instances {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add instances
	@m = map { "\$[$_]" } keys %INSTANCE;
    } else { $i++; }

    return expand($word);
}

sub expand_properties {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add properties
	eval {
	    @m = $entity->properties();
	};
    } else { $i++; }

    return expand($word);
}

sub expand_types {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add types
	@m = qw/TEXT VARCHAR BOOLEAN SET INTEGER FLOAT DATE SERIAL/;
    } else { $i++; }

    return expand($word);
}

sub expand_instance_methods {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add instance methods
	@m = qw/property link unlink fetch_related id/;
    } else { $i++; }

    return expand($word);
}

sub expand_instance_class_methods {
    my $word = shift;
    my $state = shift;

    unless( $state ) {
	# Add instance class methods
	@m = qw/new search properties get define/;
    } else { $i++; }

    return expand($word);
}

sub expand {
    my $word = shift;

    for($i||=0 ; $i<@m; $i++ ) {
	return $m[$i] unless length($word);
	return $m[$i] if $m[$i] =~ /^\Q$word/;
    }

    $i = 0;
    @m = ();
    return;
}

